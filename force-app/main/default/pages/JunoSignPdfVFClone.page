<apex:page docType="html-5.0" showHeader="false" sidebar="false" standardStylesheets="false" applyHtmlTag="false" applyBodyTag="false" controller="JunosignPdfController">
    <html>
        <head>
            <!-- Import the Design System style sheet -->
            <apex:slds />
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>JunoSign Signature Page</title>
            <!-- Load required libraries -->
            <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
            <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
            <script src="https://unpkg.com/downloadjs@1.4.7/download.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.1.5/dist/signature_pad.umd.min.js"></script>
            
            <!-- Add fonts for signature styles -->
            <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&family=Homemade+Apple&family=Caveat&family=Kalam&family=Parisienne&family=Sacramento&display=swap" rel="stylesheet" />
            <apex:stylesheet value="{!$Resource.main_preparesend}" />
            <apex:stylesheet value="{!$Resource.pixie_preparesend}" />
            <apex:stylesheet value="{!$Resource.main_usersend}" />
            
            <link href="//mozilla.github.io/pdf.js/web/viewer.css" rel="stylesheet" type="text/css" />
            <apex:stylesheet value="{!$Resource.JunoSignPdf_VF_Css}"/>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            <link href="https://lightningdesignsystem.com/assets/styles/salesforce-lightning-design-system.min.css" rel="stylesheet"/>

            <style>
              
            .highlight {
                outline: 3px solid #4F46E5;
                transition: outline 0.3s ease;
            }
            
            
            </style>
            </head>
            <apex:form >
                
            <body>
               <!-- REQUIRED SLDS WRAPPER -->
    		<div class="slds-scope"> 
                <!-- Toast Container -->
              <div id="toast" class="slds-notify slds-notify_toast" style="display:none; position:fixed; top:1rem; right:1rem; z-index:1000;">
                
                <div class="slds-notify__content">
                  <h2 id="toastMessage"></h2>
                </div>
              </div>
                  </div>
                <!-- Header -->
                <!-- header class="header">
                    <div class="header-content">
                        <h1 class="header-title">
                           <img src="{!$Resource.JunoSign}" style="width:25%;"/>
                        </h1>
                    </div>
                </header -->
                
                <!-- Main content -->
                <div class="container">
                    
                    <!-- PDF Editor -->
                    <div id="editorSection" class="editor-section">
                        <!-- Toolbar -->
                        <div class="editor-toolbar" style="justify-content: space-between;">
                            <div class="toolbar-actions">
                                <div class="relative" style="width:25%;">
                                    <img src="{!$Resource.JunoSign}" />
                                    
                                    
                                   
                                </div>
                            </div>
                            <div class="toolbar-buttons" style="display: flex;justify-content:end;">
                                <button id="gotoSign" class="btn btn-cancel" type="button">Go To Sign</button>
                                <button id="cancelBtn" class="btn btn-cancel" type="button">Reject</button>
                                 <button id="saveBtn" class="btn btn-save" type="button">
                                    Complete Signature
                                </button>
                            </div>
                        </div>
                        
                        <!-- PDF Viewer -->
                        <div id="pdfContainer" class="pdf-container">
                            <div id="loadingSpinner" class="loading-spinner">
                                <div class="spinner"></div>
                            </div>
                            
                            <div id="pdfCanvasContainer" class="pdf-canvas-container hidden">
                                <canvas id="pdfCanvas"></canvas>
                            </div>
                            
                            <!-- Page controls -->
                            <div class="page-controls" style="visibility:hidden;">
                                <button id="prevPageBtn" class="btn btn-icon" disabled = "disabled">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="m15 18-6-6 6-6" />
                                    </svg>
                                </button>
                                
                                <div class="page-info">
                                    <span id="currentPage" class="current-page">1</span>
                                    <span class="page-divider">/</span>
                                    <span id="totalPages" class="total-pages">1</span>
                                </div>
                                
                                <button id="nextPageBtn" class="btn btn-icon" disabled = "disabled">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="m9 18 6-6-6-6" />
                                    </svg>
                                </button>
                                
                                <div class="divider"></div>
                                
                                <button id="zoomOutBtn" class="btn btn-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <circle cx="11" cy="11" r="8" />
                                        <line x1="21" y1="21" x2="16.65" y2="16.65" />
                                        <line x1="8" y1="11" x2="14" y2="11" />
                                    </svg>
                                </button>
                                
                                <span id="zoomLevel" class="zoom-level">100%</span>
                                
                                <button id="zoomInBtn" class="btn btn-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <circle cx="11" cy="11" r="8" />
                                        <line x1="21" y1="21" x2="16.65" y2="16.65" />
                                        <line x1="11" y1="8" x2="11" y2="14" />
                                        <line x1="8" y1="11" x2="14" y2="11" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Enhanced Signature Pad Modal -->
                    <div id="signatureModal" class="signature-modal">
                        <div class="signature-modal-content">
                            <h3 id="signatureModalTitle" class="signature-modal-title">Add Your Signature</h3>
                            <p class="signature-modal-description">Choose how you want to add your signature</p>
                            
                            <!-- Signature Tabs -->
                            <div class="signature-tabs">
                                <div class="signature-tab active" data-tab="draw">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path>
                                        <polyline points="10 17 15 12 10 7"></polyline>
                                        <line x1="15" y1="12" x2="3" y2="12"></line>
                                    </svg>
                                    Draw
                                </div>
                                <div class="signature-tab" data-tab="type">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <polyline points="4 7 4 4 20 4 20 7"></polyline>
                                        <line x1="9" y1="20" x2="15" y2="20"></line>
                                        <line x1="12" y1="4" x2="12" y2="20"></line>
                                    </svg>
                                    Type
                                </div>
                                <div class="signature-tab" data-tab="upload">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="17 8 12 3 7 8"></polyline>
                                        <line x1="12" y1="3" x2="12" y2="15"></line>
                                    </svg>
                                    Upload
                                </div>
                                <!-- div class="signature-tab" data-tab="camera">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                        <circle cx="12" cy="13" r="4"></circle>
                                    </svg>
                                    Camera
                                </div -->
                            </div>
                            
                            <!-- Color Options -->
                            <div class="color-options">
                                <!-- div class="color-option selected" data-color="#000000" style="background-color: #000000;"></div>
                                <div class="color-option" data-color="#4285F4" style="background-color: #4285F4;"></div>
                                <div class="color-option" data-color="#19479D" style="background-color: #19479D;"></div>
                                <div class="color-option" data-color="#673AB7" style="background-color: #673AB7;"></div>
                                <div class="color-option" data-color="#777777" style="background-color: #777777;"></div>
                                <div class="color-option" data-color="#444444" style="background-color: #444444;"></div -->
                            </div>
                            
                            <!-- Draw Tab Content -->
                            <div class="signature-tab-content active" id="drawTab">
                                <p class="text-center" style="font-size: 0.875rem; color: #6b7280; margin-bottom: 0.5rem;">Sign your name using your mouse or touchpad.</p>
                                <div class="relative">
                                    <canvas id="signatureCanvas" class="signature-canvas"></canvas>
                                    <button id="clearDrawingBtn" type="button" style="position: absolute; top: 0.5rem; right: 0.5rem; background-color: white; border-radius: 9999px; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                            <path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Type Tab Content -->
                            <div class="signature-tab-content" id="typeTab">
                                <input type="text" id="typedSignature" class="signature-type-input" placeholder="Type your name" />
                                
                                <div class="font-options">
                                    <div class="font-option selected" data-font="Dancing Script">
                                        <span style="font-family: 'Dancing Script'; font-size: 1.5rem;">Your Name</span>
                                    </div>
                                    <div class="font-option" data-font="Homemade Apple">
                                        <span style="font-family: 'Homemade Apple'; font-size: 1.25rem;">Your Name</span>
                                    </div>
                                    <div class="font-option" data-font="Caveat">
                                        <span style="font-family: 'Caveat'; font-size: 1.5rem;">Your Name</span>
                                    </div>
                                    <div class="font-option" data-font="Kalam">
                                        <span style="font-family: 'Kalam'; font-size: 1.5rem;">Your Name</span>
                                    </div>
                                    <div class="font-option" data-font="Parisienne">
                                        <span style="font-family: 'Parisienne'; font-size: 1.5rem;">Your Name</span>
                                    </div>
                                    <div class="font-option" data-font="Sacramento">
                                        <span style="font-family: 'Sacramento'; font-size: 1.5rem;">Your Name</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Upload Tab Content -->
                            <div class="signature-tab-content" id="uploadTab">
                                <div class="upload-area" id="uploadArea">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style="margin: 0 auto 1rem; color: #7c3aed;">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="17 8 12 3 7 8"></polyline>
                                        <line x1="12" y1="3" x2="12" y2="15"></line>
                                    </svg>
                                    <p style="margin-bottom: 0.5rem; color: #6b7280;">Upload an image of your signature</p>
                                    <button class="btn btn-outline">Select Image</button>
                                    <input type="file" id="signatureUpload" accept="image/*" style="display: none;" />
                                </div>
                            </div>
                            
                            <!-- Camera Tab Content -->
                            <div class="signature-tab-content" id="cameraTab">
                                <div class="camera-area">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style="margin: 0 auto 1rem; color: #7c3aed;">
                                        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                        <circle cx="12" cy="13" r="4"></circle>
                                    </svg>
                                    <p style="margin-bottom: 0.5rem; color: #6b7280;">Take a photo of your signature</p>
                                    <button class="btn btn-outline" id="openCameraBtn">Open Camera</button>
                                    <video id="cameraPreview" style="display: none; width: 100%; margin-top: 1rem;"></video>
                                    <canvas id="cameraCanvas" style="display: none;"></canvas>
                                </div>
                            </div>
                            
                            <!-- Save Signature Checkbox -->
                            <!--div class="signature-save-checkbox">
                                <input type="checkbox" id="saveSignatureCheckbox" checked = "checked"/>
                                <label for="saveSignatureCheckbox" style="font-size: 0.875rem; color: #4b5563;">Save signature</label>
                            </div -->
                            
                            <div class="signature-actions">
                                <div>
                                    <button type="button" id="clearSignatureBtn" class="btn btn-outline">Clear</button>
                                </div>
                                <div class="signature-buttons">
                                    <button id="cancelSignatureBtn" class="btn btn-outline" type="button">Cancel</button>
                                    <button id="saveSignatureBtn" class="btn btn-primary" type="button">Add to Document</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Saved Signatures Modal -->
                    <div id="savedSignaturesModal" class="signature-modal">
                        <div class="signature-modal-content">
                            <h3 class="signature-modal-title">Saved Signatures</h3>
                            <p class="signature-modal-description">Select a signature to use</p>
                            
                            <div id="savedSignaturesContainer" class="signature-list">
                                <!-- Saved signatures will be populated here -->
                            </div>
                            
                            <div class="signature-actions">
                                <button id="backToSignatureBtn" class="btn btn-outline">Back</button>
                                <button id="closeSavedSignaturesBtn" class="btn btn-outline">Cancel</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Date Picker Modal -->
                    <div id="datePickerModal" class="date-picker-modal">
                        <div class="date-picker-modal-content">
                            <h3 class="signature-modal-title">Select Date</h3>
                            <div class="calendar-header" style="display:none;" >
                                <div class="calendar-navigation">
                                    <button id="prevMonthBtn" class="btn btn-outline">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                            <path d="m15 18-6-6 6-6" />
                                        </svg>
                                    </button>
                                    <span id="calendarMonthYear" class="calendar-month-year"></span>
                                    <button id="nextMonthBtn" class="btn btn-outline">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                            <path d="m9 18 6-6-6-6" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div id="calendarDays" class="calendar-grid" style="display:none;">
                                <!-- Calendar days will be populated here -->
                            </div>
                            <div class="date-format-options">
                                <div class="date-format-option selected" data-format="MM/DD/YYYY"> 
                                    <input type="radio" name="dateFormat" checked="checked" />
                                    <label>MM/DD/YYYY</label>
                                    <span id="formatPreview1"></span>
                                </div>
                                <div class="date-format-option" data-format="DD/MM/YYYY">
                                    <input type="radio" name="dateFormat" />
                                    <label>DD/MM/YYYY</label>
                                    <span id="formatPreview2"></span>
                                </div>
                                <div class="date-format-option" data-format="YYYY/MM/DD">
                                    <input type="radio" name="dateFormat" />
                                    <label>YYYY/MM/DD</label>
                                    <span id="formatPreview3"></span>
                                </div>
                                <div class="date-format-option" data-format="MMM DD, YYYY">
                                    <input type="radio" name="dateFormat" />
                                    <label>MMM DD, YYYY</label>
                                    <span id="formatPreview4"></span>
                                </div>
                            </div>
                            <div class="signature-actions">
                                <button type="button" id="cancelDateBtn" class="btn btn-outline">Cancel</button>
                                <button type="button" id="addSelectedDateBtn" class="btn btn-primary">Add Date</button>
                            </div>
                        </div>
                    </div>
                    <!-- Rejection Modal -->
                    <div id="rejectionModal" class="signature-modal">
                        <div class="signature-modal-content" style="max-width: 400px; text-align: center;">
                            <div style="width: 70px; height: 70px; background-color: #fee2e2; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none">
                                    <circle cx="12" cy="12" r="10" fill="#dc2626"/>
                                    <path d="M8 8l8 8m0-8l-8 8" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </div>
                            <h2 style="color: #dc2626; font-size: 1.5rem; margin-bottom: 1rem;">Document Rejected</h2>
                            <p style="color: #4b5563; margin-bottom: 2rem;">The document has been rejected and can no longer be edited.</p>
                            <button id="closeTabBtn" class="btn btn-primary" style="background: linear-gradient(90deg, #7c3aed 0%, #2563eb 100%);">Close Tab</button>
                        </div>
                    </div>
                    
                    <div id="successModal" class="signature-modal" style="display: none;">
                        <div class="signature-modal-content" style="max-width: 400px; text-align: center;">
                            <div style="width: 70px; height: 70px; background-color: #d1fae5; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem;">
                                <!--<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#16a34a" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
<path d="M20 6L9 17l-5-5"></path>
</svg>-->
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none">
                                    <circle cx="12" cy="12" r="10" fill="#16a34a"/>
                                    <path d="M10 14.5l-3-3 1.5-1.5 1.5 1.5 4.5-4.5 1.5 1.5-6 6z" fill="#ffffff"/>
                                </svg>
                            </div>
                            <h2 style="color: #16a34a; font-size: 1.5rem; margin-bottom: 1rem;">Document Signed</h2>
                            <p style="color: #4b5563; margin-bottom: 2rem;">The document has been signed successfully and sent to your email.</p>
                            <button id="closeSuccessTabBtn" class="btn btn-primary" style="background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);">Close Tab</button>
                        </div>
                    </div>
                </div>
                                    
                <div id="noElementsModal" class="signature-modal" style="display: none;">
                        <div class="signature-modal-content" style="max-width: 400px; text-align: center;">
                            <div style="width: 70px; height: 70px; background-color: #d1fae5; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem;">
                            <h2 style="color: #16a34a; font-size: 1.5rem; margin-bottom: 1rem;">Document Signed</h2>
                            <p style="color: #4b5563; margin-bottom: 2rem;">Not Setup Properly for Sign or Already Signed</p>
                            <button id="closeSuccessTabBtn" class="btn btn-primary" style="background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);">Close Tab</button>
                        </div>
                    </div>
                </div>
                
                <script>
                // Initialize PDF.js
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                // Global timeout for the page
        		Visualforce.remoting.timeout = 120000; 
                // Initialize variables
                let pdfDocument = null;
                let currentPage = 1;
                let totalPages = 0;
                let scale = 1.4;
                let signaturePad = null;
                let currentSignatureType = 'signature'; // 'signature' or 'initials'
                let signatures = [];
                let savedSignatures = [];
                let selectedColor = '#000000';
                let selectedFont = 'Dancing Script';
                let activeTab = 'draw';
                let isSignatureMenuOpen = false;

                let isMobile = window.innerWidth < 768;
                let isLandscape = window.innerWidth > window.innerHeight;
                let currentOrientation = screen.orientation ? screen.orientation.angle : 0;
                
                // Date picker variables
                let selectedDate = new Date();
                let currentCalendarDate = new Date();
                let selectedDateFormat = 'MM/DD/YYYY';
                
                // DOM elements
                const fileInput = document.getElementById('fileInput');
                const chooseFileBtn = document.getElementById('chooseFileBtn');
                
                const editorSection = document.getElementById('editorSection');
                const pdfCanvas = document.getElementById('pdfCanvas');
                const pdfCanvasContainer = document.getElementById('pdfCanvasContainer');
                const loadingSpinner = document.getElementById('loadingSpinner');
                const currentPageEl = document.getElementById('currentPage');
                const totalPagesEl = document.getElementById('totalPages');
                const prevPageBtn = document.getElementById('prevPageBtn');
                const nextPageBtn = document.getElementById('nextPageBtn');
                const zoomInBtn = document.getElementById('zoomInBtn');
                const zoomOutBtn = document.getElementById('zoomOutBtn');
                const zoomLevelEl = document.getElementById('zoomLevel');
                const saveBtn = document.getElementById('saveBtn');
                const cancelBtn = document.getElementById('cancelBtn');
                const pdfContainer = document.getElementById('pdfContainer');
                
                // Signature elements
                const signatureModal = document.getElementById('signatureModal');
                const signatureCanvas = document.getElementById('signatureCanvas');
                const signatureModalTitle = document.getElementById('signatureModalTitle');
                const signatureMenuBtn = document.getElementById('signatureMenuBtn');
                const signatureMenu = document.getElementById('signatureMenu');
                const savedSignaturesList = document.getElementById('savedSignaturesList');
                const noSavedSignatures = document.getElementById('noSavedSignatures');
                const clearSignatureBtn = document.getElementById('clearSignatureBtn');
                const cancelSignatureBtn = document.getElementById('cancelSignatureBtn');
                const saveSignatureBtn = document.getElementById('saveSignatureBtn');
            // const saveSignatureCheckbox = document.getElementById('saveSignatureCheckbox');
                const clearDrawingBtn = document.getElementById('clearDrawingBtn');
                const typedSignature = document.getElementById('typedSignature');
                const signatureTabs = document.querySelectorAll('.signature-tab');
                const signatureTabContents = document.querySelectorAll('.signature-tab-content');
                const colorOptions = document.querySelectorAll('.color-option');
                const fontOptions = document.querySelectorAll('.font-option');
                const uploadArea = document.getElementById('uploadArea');
                const signatureUpload = document.getElementById('signatureUpload');
                const openCameraBtn = document.getElementById('openCameraBtn');
                const cameraPreview = document.getElementById('cameraPreview');
                const cameraCanvas = document.getElementById('cameraCanvas');
                
                // Date picker elements
                const datePickerModal = document.getElementById('datePickerModal');
                const calendarMonthYear = document.getElementById('calendarMonthYear');
                const calendarDays = document.getElementById('calendarDays');
                const prevMonthBtn = document.getElementById('prevMonthBtn');
                const nextMonthBtn = document.getElementById('nextMonthBtn');
                const cancelDateBtn = document.getElementById('cancelDateBtn');
                const addSelectedDateBtn = document.getElementById('addSelectedDateBtn');
                const dateFormatOptions = document.querySelectorAll('.date-format-option');
                const formatPreviews = document.querySelectorAll('[id^="formatPreview"]');
                
                // Initialize event listeners
            /*  document.addEventListener('DOMContentLoaded', function() {
                    
                    window.addEventListener('orientationchange', handleOrientationChange);
                    window.addEventListener('resize', debounce(handleResize, 250));
                    
                    const gotoSignBtn = document.getElementById('gotoSign');
                      gotoSignBtn.addEventListener('click', () => {
                        const signFields = document.querySelectorAll('.signaturedragfield');
                        if (signFields.length > 0) {
                          const target = signFields[0];
                          target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                          target.classList.add('highlight');
                          setTimeout(() => target.classList.remove('highlight'), 2000);
                        } else {
                                          //alert('No signature fields found.');
            			  showToast('No signature fields found.', 'info');
                        }
                      });

                    // Load saved signatures
            //loadSavedSignatures();
                    
                    // Check for ID parameter in URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const id = urlParams.get('id');
                    const conid = urlParams.get('conid');
                    const recid = urlParams.get('recid');
                    // alert('id>>>>>>>>>>>>'+id+'conid>>>>>>>>>>>>>'+conid+'recid>>>>>>>>>>>>>>>>>>>'+recid);
                    
                    if (id && conid && recid) {
                        editorSection.style.display = 'flex';
                        // loadPDFFromId(id, conid);
                        loadPDFFromId(id, conid, recid);
                    } else {
                        // alert("Missing required parameters. Please include 'id' and 'conid' in the URL.");
                        editorSection.style.display = 'none';
                    }
                    
                    // Ensure proper initial display
                    //uploadSection.style.display = 'block';
                    //editorSection.style.display = 'none';
                    
                    // File upload
                    //chooseFileBtn.addEventListener('click', function() {
                    //    fileInput.click();
                    //});
                    
                    //fileInput.addEventListener('change', handleFileUpload);
                    
                    // PDF navigation
                    prevPageBtn.addEventListener('click', prevPage);
                    nextPageBtn.addEventListener('click', nextPage);
                    zoomInBtn.addEventListener('click', zoomIn);
                    zoomOutBtn.addEventListener('click', zoomOut);
                    
                    // Signature menu
                    //signatureMenuBtn.addEventListener('click', toggleSignatureMenu);
                    
                    // Close signature menu when clicking outside
                    
                    
                    // Signature tabs
                    signatureTabs.forEach(tab => {
                        tab.addEventListener('click', function() {
                        const tabName = this.getAttribute('data-tab');
                        switchSignatureTab(tabName);
                    });
                    });
                        
                        // Color options
                        colorOptions.forEach(option => {
                        option.addEventListener('click', function() {
                        selectedColor = this.getAttribute('data-color');
                        colorOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        
                        // Update signature pad color if active
                        if (signaturePad && activeTab === 'draw') {
                        signaturePad.penColor = selectedColor;
                    }
                        
                        // Update typed signature color
                        updateTypedSignaturePreview();
                    });
                    });
                        
                        // Font options
                        fontOptions.forEach(option => {
                        option.addEventListener('click', function() {
                        selectedFont = this.getAttribute('data-font');
                        fontOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        
                        // Update typed signature preview
                        updateTypedSignaturePreview();
                    });
                    });
                        
                        // Typed signature input
                        typedSignature.addEventListener('input', updateTypedSignaturePreview);
                        
                        // Upload area
                        uploadArea.addEventListener('click', function() {
                        signatureUpload.click();
                    });
                        
                        signatureUpload.addEventListener('change', handleSignatureImageUpload);
                        
                        // Camera button
                        openCameraBtn.addEventListener('click', openCamera);
                        
                        // Signature actions
                        clearDrawingBtn.addEventListener('click', clearSignature);
                        clearSignatureBtn.addEventListener('click', clearSignature);
                        cancelSignatureBtn.addEventListener('click', closeSignaturePad);
                        saveSignatureBtn.addEventListener('click', addSignatureToDocument);
                        
                        // Actions
                        saveBtn.addEventListener('click', savePDF);
                        // Update the cancelBtn event listener
                        cancelBtn.addEventListener('click', function() {
                        if (!confirm('Are you sure you want to reject this document? This action cannot be undone.')) {
                            return;
                        }
                        
                        const urlParams = new URLSearchParams(window.location.search);
                        const  id= urlParams.get('id');
                        const conid = urlParams.get('conid');
                        const recid = urlParams.get('recid');
                        
                        if (!id || !conid || !recid) {
                            //alert('Missing required parameters to reject the document.');
                             showToast('Missing required parameters to reject the document.', 'error');
                             return;
                        }
                        
                        showLoading(true);
                        
                        Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.JunosignPdfController.rejectDocument}',
                        id,
                        conid,
                        recid,
                        function(result, event) {
                        showLoading(false);
                        if (event.status) {
                        console.log('Document rejected successfully:', result);
                        showRejectionModal(); // Updated function will handle tab closing
                        disableEditing();
                    } else {
                        console.error('Error rejecting document:', event.message);
                        // alert('Error rejecting document: ' + event.message);
                        showToast('Error rejecting document: ' + event.message, 'error');
                    }
                    },
                        { escape: false, timeout: 120000 }
                                         );
                });
                
                // Function to disable editing after rejection
                function disableEditing() {
                    document.querySelectorAll('.editor-toolbar .btn').forEach(button => {
                        button.disabled = true;
                        button.style.opacity = '0.5';
                        button.style.cursor = 'not-allowed';
                    });
                        
                        pdfContainer.style.pointerEvents = 'none';
                        
                        document.querySelectorAll('.draggable').forEach(element => {
                        element.style.pointerEvents = 'none';
                    });
                    }
                        // Date picker initialization
                        prevMonthBtn.addEventListener('click', () => {
                        currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
                        renderCalendar();
                    });
                        
                        nextMonthBtn.addEventListener('click', () => {
                        currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
                        renderCalendar();
                    });
                        
                        cancelDateBtn.addEventListener('click', () => {
                        datePickerModal.style.display = 'none';
                    });
                        
                        addSelectedDateBtn.addEventListener('click', () => {
                        const formattedDate = formatDate(selectedDate, selectedDateFormat);
                        addDateToDocument(formattedDate);
                        datePickerModal.style.display = 'none';
                    });
                        
                        dateFormatOptions.forEach(option => {
                        option.addEventListener('click', function() {
                        selectedDateFormat = this.getAttribute('data-format');
                        dateFormatOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        updateFormatPreviews();
                    });
                    });
                        
                        // Initialize SignaturePad when the modal is opened
                        // initializeSignaturePad();
                        
                        // Make PDF container a drop zone for signatures
                       
                    });*/
            
            document.addEventListener('DOMContentLoaded', function() {
    window.addEventListener('orientationchange', handleOrientationChange);
    window.addEventListener('resize', debounce(handleResize, 250));
    
    const gotoSignBtn = document.getElementById('gotoSign');
    gotoSignBtn.addEventListener('click', () => {
        const signFields = document.querySelectorAll('.signaturedragfield');
        if (signFields.length > 0) {
            const target = signFields[0];
            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
            target.classList.add('highlight');
            setTimeout(() => target.classList.remove('highlight'), 2000);
        } else {
            showToast('No signature fields found.', 'info');
        }
    });

    // Check for ID parameter in URL
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    const conid = urlParams.get('conid');
    const recid = urlParams.get('recid');
    
    if (id && conid && recid) {
        editorSection.style.display = 'flex';
        // First validate recipient access before loading PDF
        validateRecipientAccess();
    } else {
        showErrorModal('Missing required parameters. Please include id, conid, and recid in the URL.', 'MISSING_PARAMS');
        editorSection.style.display = 'none';
    }
    
    // PDF navigation
    prevPageBtn.addEventListener('click', prevPage);
    nextPageBtn.addEventListener('click', nextPage);
    zoomInBtn.addEventListener('click', zoomIn);
    zoomOutBtn.addEventListener('click', zoomOut);
    
    // Signature tabs
    signatureTabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');
            switchSignatureTab(tabName);
        });
    });
    
    // Color options
    colorOptions.forEach(option => {
        option.addEventListener('click', function() {
            selectedColor = this.getAttribute('data-color');
            colorOptions.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            
            // Update signature pad color if active
            if (signaturePad && activeTab === 'draw') {
                signaturePad.penColor = selectedColor;
            }
            
            // Update typed signature color
            updateTypedSignaturePreview();
        });
    });
    
    // Font options
    fontOptions.forEach(option => {
        option.addEventListener('click', function() {
            selectedFont = this.getAttribute('data-font');
            fontOptions.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            
            // Update typed signature preview
            updateTypedSignaturePreview();
        });
    });
    
    // Typed signature input
    typedSignature.addEventListener('input', updateTypedSignaturePreview);
    
    // Upload area
    uploadArea.addEventListener('click', function() {
        signatureUpload.click();
    });
    
    signatureUpload.addEventListener('change', handleSignatureImageUpload);
    
    // Camera button
    openCameraBtn.addEventListener('click', openCamera);
    
    // Signature actions
    clearDrawingBtn.addEventListener('click', clearSignature);
    clearSignatureBtn.addEventListener('click', clearSignature);
    cancelSignatureBtn.addEventListener('click', closeSignaturePad);
    saveSignatureBtn.addEventListener('click', addSignatureToDocument);
    
    // Actions
    saveBtn.addEventListener('click', savePDF);
    
    // Update the cancelBtn event listener
    cancelBtn.addEventListener('click', function() {
        if (!confirm('Are you sure you want to reject this document? This action cannot be undone.')) {
            return;
        }
        
        const urlParams = new URLSearchParams(window.location.search);
        const id = urlParams.get('id');
        const conid = urlParams.get('conid');
        const recid = urlParams.get('recid');
        
        if (!id || !conid || !recid) {
            showToast('Missing required parameters to reject the document.', 'error');
            return;
        }
        
        showLoading(true);
        
        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.JunosignPdfController.rejectDocument}',
            id,
            conid,
            recid,
            function(result, event) {
                showLoading(false);
                if (event.status) {
                    console.log('Document rejected successfully:', result);
                    showRejectionModal();
                    disableEditing();
                } else {
                    console.error('Error rejecting document:', event.message);
                    showToast('Error rejecting document: ' + event.message, 'error');
                }
            },
            { escape: false, timeout: 120000 }
        );
    });
    
    // Function to disable editing after rejection
    function disableEditing() {
        document.querySelectorAll('.editor-toolbar .btn').forEach(button => {
            button.disabled = true;
            button.style.opacity = '0.5';
            button.style.cursor = 'not-allowed';
        });
        
        pdfContainer.style.pointerEvents = 'none';
        
        document.querySelectorAll('.draggable').forEach(element => {
            element.style.pointerEvents = 'none';
        });
    }
    
    // Date picker initialization
    prevMonthBtn.addEventListener('click', () => {
        currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
        renderCalendar();
    });
    
    nextMonthBtn.addEventListener('click', () => {
        currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
        renderCalendar();
    });
    
    cancelDateBtn.addEventListener('click', () => {
        datePickerModal.style.display = 'none';
    });
    
    addSelectedDateBtn.addEventListener('click', () => {
        const formattedDate = formatDate(selectedDate, selectedDateFormat);
        addDateToDocument(formattedDate);
        datePickerModal.style.display = 'none';
    });
    
    dateFormatOptions.forEach(option => {
        option.addEventListener('click', function() {
            selectedDateFormat = this.getAttribute('data-format');
            dateFormatOptions.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            updateFormatPreviews();
        });
    });
});
                        
                        // Load saved signatures from localStorage
                        function loadSavedSignatures() {
                        const savedSignaturesData = localStorage.getItem('savedSignatures');
                        if (savedSignaturesData) {
                        try {
                        savedSignatures = JSON.parse(savedSignaturesData);
                        updateSavedSignaturesList();
                    } catch (e) {
                        console.error('Error loading saved signatures:', e);
                        savedSignatures = [];
                    }
                    }
                    }
                        
                        // Update the saved signatures list in the menu
                        function updateSavedSignaturesList() {
                        savedSignaturesList.innerHTML = '';
                        
                        if (savedSignatures.length > 0) {
                        noSavedSignatures.style.display = 'none';
                        savedSignaturesList.style.display = 'block';
                        
                        savedSignatures.forEach((sig, index) => {
                        const item = document.createElement('div');
                        item.className = 'signature-menu-item';
                        item.innerHTML = `
                        <img src="${sig}" alt="Signature ${index + 1}" />
                        <button class="delete-btn" data-index="${index}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                        </button>
                        `;
                        
                        // Add click event to use this signature
                        item.addEventListener('click', function(e) {
                        if (!e.target.closest('.delete-btn')) {
                        //useSavedSignature(sig);
                    }
                    });
                        
                        savedSignaturesList.appendChild(item);
                    });
                        
                        // Add delete button event listeners
                        document.querySelectorAll('.delete-btn').forEach(btn => {
                        btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const index = Number.parseInt(this.getAttribute('data-index'));
                        deleteSavedSignature(index);
                    });
                    });
                    } else {
                        noSavedSignatures.style.display = 'block';
                        savedSignaturesList.style.display = 'none';
                    }
                    }
                        
                        // Use a saved signature
                        function useSavedSignature(signatureDataUrl) {
                        // Create a unique ID for this signature
                        const signatureId = 'sig-' + Date.now();
                        
                        // Create an image element
                        const signatureImg = document.createElement('img');
                        signatureImg.src = signatureDataUrl;
                        signatureImg.className = 'signature-image';
                        signatureImg.id = signatureId;
                        signatureImg.alt = 'Signature';
                        signatureImg.draggable = false; // Prevent default dragging
                        
                        // Position the signature in the center of the visible area
                        const pdfContainerRect = pdfContainer.getBoundingClientRect();
                        const centerX = pdfContainerRect.width / 2;
                        const centerY = pdfContainerRect.height / 2 - 50; // Slightly above center
                        
                        // Add delete control
                        const deleteControl = document.createElement('div');
                        deleteControl.className = 'signature-element-controls';
                        deleteControl.innerHTML = `
                        <div class="signature-element-delete" data-id="${signatureId}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M3 6h18"></path>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
                        <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                        </div>
                        `;
                        
                        // Create a wrapper for the signature and controls
                        const wrapper = document.createElement('div');
                        //wrapper.className = 'draggable';
                        wrapper.id = 'wrapper-' + signatureId;
                        wrapper.style.left = `${centerX - 100}px`;
                        wrapper.style.top = `${centerY}px`;
                        wrapper.appendChild(signatureImg);
                        wrapper.appendChild(deleteControl);
                        
                        // Make the wrapper draggable and resizable
                        //makeDraggable(wrapper);
                        
                        // Add to editor
                        pdfContainer.appendChild(wrapper);
                        
                        // Add to signatures array
                        signatures.push({
                        id: signatureId,
                        type: 'signature',
                        element: wrapper,
                        dataUrl: signatureDataUrl
                    });
                    
                    // Add delete event listener
                    /* deleteControl.querySelector('.signature-element-delete').addEventListener('click', function() {
                        const id = this.getAttribute('data-id');
                        deleteSignature(id);
                    });*/
                    
                    // Add a subtle animation effect
                    wrapper.style.opacity = '0';
                    setTimeout(() => {
                        wrapper.style.transition = 'opacity 0.3s ease';
                        wrapper.style.opacity = '1';
                    }, 10);
                        
                        // Close the menu
                        closeSignatureMenu();
                    }
                        
                        // Delete a saved signature
                        function deleteSavedSignature(index) {
                        savedSignatures.splice(index, 1);
                        localStorage.setItem('savedSignatures', JSON.stringify(savedSignatures));
                        updateSavedSignaturesList();
                    }
                        
                        // Delete a signature from the document
                        function deleteSignature(id) {
                        const wrapper = document.getElementById('wrapper-' + id);
                        if (wrapper) {
                        // Add removal animation
                        wrapper.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        wrapper.style.opacity = '0';
                        wrapper.style.transform += ' scale(0.9)';
                        
                        // Remove after animation completes
                        setTimeout(() => {
                        wrapper.remove();
                    }, 300);
                    }
                        
                        signatures = signatures.filter(sig => sig.id !== id);
                    }
                        
                        // Toggle signature menu
                        function toggleSignatureMenu() {
                        if (isSignatureMenuOpen) {
                        // closeSignatureMenu();
                    } else {
                        // openSignatureMenu();
                    }
                    }
                        
                        // Open signature menu
                        function openSignatureMenu() {
                        // signatureMenu.style.display = 'block';
                        isSignatureMenuOpen = true;
                    }
                        
                        // Close signature menu
                        function closeSignatureMenu() {
                        //signatureMenu.style.display = 'none';
                        isSignatureMenuOpen = false;
                    }
                        
                        // Switch signature tab
                        function switchSignatureTab(tabName) {
                        activeTab = tabName;
                        
                        // Update tab UI
                        signatureTabs.forEach(tab => {
                        if (tab.getAttribute('data-tab') === tabName) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                    });
                        
                        // Update content UI
                        signatureTabContents.forEach(content => {
                        if (content.id === tabName + 'Tab') {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                    });
                        
                        // Initialize signature pad if draw tab is active
                        if (tabName === 'draw') {
                        setTimeout(() => {
                        initializeSignaturePad();
                    }, 100);
                    }
                    }
                        
                        // Update typed signature preview
                        function updateTypedSignaturePreview() {
                        const name = typedSignature.value || 'Your Name';
                        
                        fontOptions.forEach(option => {
                        const font = option.getAttribute('data-font');
                        const preview = option.querySelector('span');
                        preview.textContent = name;
                        preview.style.color = selectedColor;
                    });
                    }
                        
                        // Handle signature image upload
                        function handleSignatureImageUpload(e) {
                        if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        
                        reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                        // Create a canvas to resize and process the image
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Set a reasonable size for the signature
                        const maxWidth = 400;
                        const maxHeight = 200;
                        let width = img.width;
                        let height = img.height;
                        
                        // Scale down if needed
                        if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                        if (height > maxHeight) {
                        width = (width * maxHeight) / height;
                        height = maxHeight;
                    }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Draw white background
                        // ctx.fillStyle = 'white';
                        //ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the image
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Get the data URL
                        const dataUrl = canvas.toDataURL();
                        
                        // Save and use the signature
                        /* if (saveSignatureCheckbox.checked) {
                        savedSignatures.push(dataUrl);
                        localStorage.setItem('savedSignatures', JSON.stringify(savedSignatures));
                        updateSavedSignaturesList();
                    }*/
                        
                        // Add to document
                        addSignatureImageToDocument(dataUrl);
                        
                        // Close modal
                        closeSignaturePad();
                    };
                        img.src = event.target.result.toString();
                    };
                        
                        reader.readAsDataURL(file);
                    }
                    }
                        
                        // Open camera for signature capture
                        function openCamera() {
                        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                        navigator.mediaDevices.getUserMedia({ video: true })
                    .then((stream) => {
                        cameraPreview.style.display = 'block';
                        openCameraBtn.textContent = 'Take Photo';
                        
                        cameraPreview.srcObject = stream;
                        cameraPreview.play();
                        
                        // Change button to take photo
                        openCameraBtn.removeEventListener('click', openCamera);
                        openCameraBtn.addEventListener('click', takePhoto);
                    })
                        .catch((error) => {
                        console.error('Camera error:', error);
                        //alert('Could not access camera. Please check permissions or try another method.');
                        showToast('Could not access camera. Please check permissions or try another method.', 'error');

                    });
                    } else {
                        //alert('Camera not supported in this browser. Please try another method.');
                        showToast('Camera not supported in this browser. Please try another method.', 'error');
                    }
                    }
                        
                        // Take photo from camera
                        function takePhoto() {
                        const context = cameraCanvas.getContext('2d');
                        
                        // Set canvas dimensions to match video
                        cameraCanvas.width = cameraPreview.videoWidth;
                        cameraCanvas.height = cameraPreview.videoHeight;
                        
                        // Draw video frame to canvas
                        context.drawImage(cameraPreview, 0, 0, cameraCanvas.width, cameraCanvas.height);
                        
                        // Get data URL
                        const dataUrl = cameraCanvas.toDataURL('image/png');
                        
                        // Stop camera stream
                        const stream = cameraPreview.srcObject;
                        const tracks = stream.getTracks();
                        tracks.forEach(track => track.stop());
                        
                        // Reset UI
                        cameraPreview.style.display = 'none';
                        openCameraBtn.textContent = 'Open Camera';
                        openCameraBtn.removeEventListener('click', takePhoto);
                        openCameraBtn.addEventListener('click', openCamera);
                        
                        // Save and use the signature
                        /* if (saveSignatureCheckbox.checked) {
                        savedSignatures.push(dataUrl);
                        localStorage.setItem('savedSignatures', JSON.stringify(savedSignatures));
                        updateSavedSignaturesList();
                    }*/
                        
                        // Add to document
                        addSignatureImageToDocument(dataUrl);
                        
                        // Close modal
                        closeSignaturePad();
                    }
                        
                        // Initialize signature pad
                    function initializeSignaturePad() {
                        // Initialize only if not already initialized
						if (!signaturePad && signatureCanvas) {
                        	signaturePad = new SignaturePad(signatureCanvas, {
                                        // backgroundColor: 'rgb(255, 255, 255)',
                                        penColor: selectedColor
                                    });
                    
                            // Resize canvas to fit container
                            resizeSignatureCanvas();
                            window.addEventListener('resize', resizeSignatureCanvas);
                        } else if (signaturePad) {
                            // Update pen color
                            signaturePad.penColor = selectedColor;
                        }
                }
                
                // Resize signature canvas
                function resizeSignatureCanvas() {
                    if (signatureCanvas && signaturePad) {
                        const ratio = Math.max(window.devicePixelRatio || 1, 1);
                        signatureCanvas.width = signatureCanvas.offsetWidth * ratio;
                        signatureCanvas.height = signatureCanvas.offsetHeight * ratio;
                        signatureCanvas.getContext("2d").scale(ratio, ratio);
                        signaturePad.clear(); // Clear the canvas
                    }
                }
                
                var selectedTarget;
                // Open signature pad modal
                function openSignaturePad(event) {
                    selectedTarget = event.currentTarget;
                    // Close the menu
                    closeSignatureMenu();
                    let type = event.currentTarget.dataset.type
                    currentSignatureType = type;
                    signatureModal.style.display = 'flex';
                    
                    // Clear any existing signature
                    clearSignature();
                    
                    // Set the appropriate title
                    signatureModalTitle.textContent = type === 'signature' ? 'Add Your Signature' : 'Add Your Text/Initials';
                    
                    if(type == 'signature'){
                        
                    	// Reset to draw tab
                    	switchSignatureTab('draw');
                        document.getElementsByClassName('signature-tabs')[0].style.display = 'flex'
                    }else{
                    	// Reset to type tab
                    	switchSignatureTab('type');
                        document.getElementsByClassName('signature-tabs')[0].style.display = 'none'
                    }
                    
                    
                    
                    
                    // Initialize if not already done
                    setTimeout(() => {
                        signaturePad = null;
                        initializeSignaturePad();
                    }, 500);
                        
                        closeSignatureMenu();
                    }
                        
                        // Close signature pad modal
                   function closeSignaturePad() {
                        // Close the menu
                        closeSignatureMenu();
                        signatureModal.style.display = 'none';
                        
                        // Reset camera if active
                        if (cameraPreview.srcObject) {
                                const stream = cameraPreview.srcObject;
                                const tracks = stream.getTracks();
                                tracks.forEach(track => track.stop());
                                cameraPreview.style.display = 'none';
                                openCameraBtn.textContent = 'Open Camera';
                                openCameraBtn.removeEventListener('click', takePhoto);
                                openCameraBtn.addEventListener('click', openCamera);
                        }
                    }
                        
                        // Clear signature
                 function clearSignature() {
                    if (activeTab === 'draw' && signaturePad) {
                        signaturePad.clear();
                        signaturePad = null;
                        initializeSignaturePad();
                        //signaturePad = null;
                    } else if (activeTab === 'type') {
                        typedSignature.value = '';
                        updateTypedSignaturePreview();
                    }
                    }
                        
                        // Add signature to document
                   function addSignatureToDocument() {
                        let dataUrl = '';
                        
                        if (activeTab === 'draw') {
                            if (signaturePad && !signaturePad.isEmpty()) {
                                dataUrl = signaturePad.toDataURL();
                            } else {
                                //alert('Please provide a signature first');
                                showToast('Please provide a signature first', 'info');
                                return;
                            }
                    	} else if (activeTab === 'type') {
                            const name = typedSignature.value.trim();
                            if (!name) {
                                //alert('Please type your name first');
                                showToast('Please type your name first', 'info');
                                return;
                        	}
                            const placeholderWidth = selectedTarget.offsetWidth;  // e.g. width of the signature box
                            const placeholderHeight = selectedTarget.offsetHeight; // height of the signature box
                            const dpr = window.devicePixelRatio || 1;
                            const baseFontSize = placeholderHeight * 0.8; // 80% of placeholder height
                            const maxTextWidth = placeholderWidth * 0.9; // leave some margin
                            const minFontSize = placeholderHeight * 0.4; // don't go smaller than 40%
                            
                            let finalFontSize = baseFontSize;
                            
                            
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.font = `${baseFontSize}px "${selectedFont}"`;
                            let textWidth = tempCtx.measureText(name).width;
                            
                            if (textWidth > maxTextWidth) {
                                const scaleFactor = maxTextWidth / textWidth;
                                finalFontSize = Math.max(baseFontSize * scaleFactor, minFontSize);
                                tempCtx.font = `${finalFontSize}px "${selectedFont}"`;
                                textWidth = tempCtx.measureText(name).width;
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = placeholderWidth * dpr;
                            canvas.height = placeholderHeight * dpr;
                            canvas.style.width = `${placeholderWidth}px`;
                            canvas.style.height = `${placeholderHeight}px`;
                            
                            const ctx = canvas.getContext('2d');
                            ctx.scale(dpr, dpr);
                            
                            // Now use final font
                            ctx.font = `${finalFontSize}px "${selectedFont}"`;
                            ctx.fillStyle = selectedColor;
                            ctx.textBaseline = 'middle';
                            
                            // Center text
                            const x = (placeholderWidth - textWidth) / 2;
                            const y = placeholderHeight / 2;
                            
                            ctx.fillText(name, x, y);
                            
    
                            dataUrl = canvas.toDataURL();
    
                        } else {
                        // Upload and camera are handled by their own functions
                        return;
                    }
                        
                        if (dataUrl) {
                        // Save signature if checkbox is checked
                        /*if (saveSignatureCheckbox.checked) {
                        savedSignatures.push(dataUrl);
                        localStorage.setItem('savedSignatures', JSON.stringify(savedSignatures));
                        updateSavedSignaturesList();
                    }*/
                        
                        // Add to document
                        addSignatureImageToDocument(dataUrl);
                        
                        // Close modal
                        closeSignaturePad();
                    }
                    }
                        
                        // Add signature image to document with improved positioning
                        function addSignatureImageToDocument(dataUrl) {
                        // Create a unique ID for this signature
                        const signatureId = 'sig-' + Date.now();
                        
                        // Create an image element
                        const signatureImg = document.createElement('img');
                        signatureImg.src = dataUrl;
                        signatureImg.className = 'signature-image';
                        signatureImg.id = signatureId;
                        signatureImg.alt = currentSignatureType === 'signature' ? 'Signature' : 'Initials';
                        signatureImg.draggable = false; // Prevent default dragging
                        
                        // Determine device type based on viewport width
                        const isMobile = window.innerWidth < 768;
                        
                        // Set initial width and height based on device type
                        //signatureImg.style.width = isMobile ? '80px' : '150px'; // Smaller on mobile, larger on PC
                        //signatureImg.style.height = isMobile ? '40px' : '75px'; // Smaller on mobile, larger on PC
                         let childElement = selectedTarget.parentElement.querySelector('.signaturedragfield');
                        // signatureImg.style.height = 10+selectedTarget.offsetHeight+'px'
                        signatureImg.style.width = selectedTarget.offsetWidth+'px'
                        
                        // Add delete control
                        const deleteControl = document.createElement('div');
                        deleteControl.className = 'signature-element-controls';
                        deleteControl.innerHTML = `
                        
                        <div class="reset-icon" onclick="resetField(this)" >
                                                            <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                                                <path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/>
                                                            </svg>
                                                         
                        </div>
                        `;
                        
                        // Get the center of the visible PDF area
                        const pdfContainerRect = selectedTarget.parentElement.getBoundingClientRect();// pdfContainer.getBoundingClientRect();
                        //const centerX = pdfContainerRect.width / 2;
                        //const centerY = pdfContainerRect.height / 2 - 50; // Slightly above center
                        
                        // Create a wrapper for the signature and controls
                        const wrapper = document.createElement('div');
                        //wrapper.className = 'draggable';
                        wrapper.id = 'wrapper-' + signatureId;
                        wrapper.style.position = 'absolute';
                        //wrapper.style.height = 30+selectedTarget.offsetHeight+'px'
                        wrapper.style.width = selectedTarget.offsetWidth+'px'
                        // Position in the center, adjusted for new dimensions
                        const sigWidth = isMobile ? 80 : 150;
                        const sigHeight = isMobile ? 40 : 75;
                        //wrapper.style.left = `${centerX - (sigWidth / 2)}px`; // Adjusted for new width
                        //       wrapper.style.top = `${centerY - (sigHeight / 2)}px`; // Adjusted for new height
                
                wrapper.appendChild(signatureImg);
                wrapper.appendChild(deleteControl);
                
                // Make the wrapper draggable and resizable
                        //makeDraggable(wrapper);
            
                        
                        // Add to editor
                        selectedTarget.parentElement.appendChild(wrapper);
                        
                        selectedTarget.parentElement.removeChild(childElement);
            
                // Add to signatures array
                signatures.push({
                    id: signatureId,
                    type: currentSignatureType,
                    element: wrapper,
                    dataUrl: dataUrl,
                });
                
                // Add delete event listener
                    /*.querySelector('.signature-element-delete').addEventListener('click', function() {
                    const id = this.getAttribute('data-id');
                    deleteSignature(id);
                });*/
                
                // Add a subtle animation effect
                wrapper.style.opacity = '0';
                setTimeout(() => {
                    wrapper.style.transition = 'opacity 0.3s ease';
                    wrapper.style.opacity = '1';
                    selectedTarget= null;
                    //savedSignaturesList.style.display = 'none';
                }, 10);
                }
                    
                    // Add date to document
                    function addDate(event) {
                    selectedTarget = event.currentTarget
                    selectedDate = new Date();
                    currentCalendarDate = new Date();
                    selectedDateFormat = 'MM/DD/YYYY';
                    datePickerModal.style.display = 'flex';
                    renderCalendar();
                    updateFormatPreviews();
                    closeSignatureMenu();
                }
                    
                    // Render calendar for date picker
                    function renderCalendar() {
                    calendarDays.innerHTML = '';
                    
                    const year = currentCalendarDate.getFullYear();
                    const month = currentCalendarDate.getMonth();
                    calendarMonthYear.textContent = `${currentCalendarDate.toLocaleString('default', { month: 'long' })} ${year}`;
                
                // Add day names
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                dayNames.forEach(day => {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day-name';
                    dayElement.textContent = day;
                    calendarDays.appendChild(dayElement);
                });
                
                // Get first day of the month
                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const prevMonthDays = new Date(year, month, 0).getDate();
                
                // Add previous month's days
                for (let i = firstDay - 1; i >= 0; i--) {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day other-month';
                    dayElement.textContent = prevMonthDays - i;
                    calendarDays.appendChild(dayElement);
                }
                
                // Add current month's days
                const today = new Date();
                for (let day = 1; day <= daysInMonth; day++) {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day';
                    dayElement.textContent = day;
                    
                    const currentDate = new Date(year, month, day);
                    if (currentDate.toDateString() === today.toDateString()) {
                        dayElement.classList.add('today');
                    }
                    if (currentDate.toDateString() === selectedDate.toDateString()) {
                        dayElement.classList.add('selected');
                    }
                    
                    dayElement.addEventListener('click', () => {
                        selectedDate = new Date(year, month, day);
                        renderCalendar();
                        updateFormatPreviews();
                    });
                        
                        calendarDays.appendChild(dayElement);
                    }
                        
                        // Add next month's days to fill the grid
                        const totalDays = firstDay + daysInMonth;
                        const remainingDays = (7 - (totalDays % 7)) % 7;
                        for (let i = 1; i <= remainingDays; i++) {
                        const dayElement = document.createElement('div');
                        dayElement.className = 'calendar-day other-month';
                        dayElement.textContent = i;
                        calendarDays.appendChild(dayElement);
                    }
                    }
                        
                        // Format date according to selected format
                        function formatDate(date, format) {
                        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                        const day = String(date.getDate()).padStart(2, '0');
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const year = date.getFullYear();
                        const monthName = monthNames[date.getMonth()];
                        
                        switch (format) {
                        case 'MM/DD/YYYY':
                        return `${month}/${day}/${year}`;
                                                case 'DD/MM/YYYY':
                                                return `${day}/${month}/${year}`;
                                                case 'YYYY/MM/DD':
                                                return `${year}/${month}/${day}`;
                                                case 'MMM DD, YYYY':
                                                return `${monthName} ${day}, ${year}`;
                                                default:
                                                return date.toLocaleDateString();
                }
                }
                
                // Update date format previews
                function updateFormatPreviews() {
                    formatPreviews.forEach(preview => {
                        const format = preview.parentElement.getAttribute('data-format');
                        preview.textContent = formatDate(selectedDate, format);
                    });
                }
                
                // Add formatted date to document
                function addDateToDocument(formattedDate) {
                    // Create a unique ID for this date element
                    const dateId = 'date-' + Date.now();
                    
                    // Create the date element
                    const dateElement = document.createElement('div');
                    dateElement.className = 'date-element';
                    dateElement.id = dateId;
                    dateElement.textContent = formattedDate;
                    
                    const isMobile = window.innerWidth < 768;
                    const isLandscape = window.innerWidth > window.innerHeight;
                    
                    if (isMobile) {
                        dateElement.style.minWidth = 0;
                        dateElement.style.padding = 0;
                        
                        if (isLandscape) {
                            dateElement.style.width = '80px';
                            dateElement.style.fontSize = '12px';
                        } else {
                            dateElement.style.width = '70px';
                            dateElement.style.fontSize = '11px';
                        }
                    } else {
                        dateElement.style.width = '100px';
                        dateElement.style.fontSize = '14px';
                    }
                    
                    // Add delete control
                    const deleteControl = document.createElement('div');
                    deleteControl.className = 'signature-element-controls';
                    deleteControl.innerHTML = `
        <div class="reset-icon" onclick="resetField(this)" >
            <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/>
            </svg>
        </div>
    `;
                    
                    // Create a wrapper for the date and controls
                    const wrapper = document.createElement('div');
                    wrapper.id = 'wrapper-' + dateId;
                    wrapper.style.position = 'absolute';
                    
                    wrapper.style.touchAction = 'none';
                    wrapper.style.userSelect = 'none';
                    
                    wrapper.appendChild(dateElement);
                    wrapper.appendChild(deleteControl);
                    
                    let childElement = selectedTarget.parentElement.querySelector('.signaturedragfield');
                    // Add to editor
                    selectedTarget.parentElement.appendChild(wrapper);
                    selectedTarget.parentElement.removeChild(childElement);
                    
                    // Add to signatures array (treating dates as a type of signature for management)
                    signatures.push({
                        id: dateId,
                        type: 'date',
                        element: wrapper,
                        text: formattedDate
                    });
                    
                    // Add a subtle animation effect
                    wrapper.style.opacity = '0';
                    setTimeout(() => {
                        wrapper.style.transition = 'opacity 0.3s ease';
                        wrapper.style.opacity = '1';
                    }, 10);
                }
                        
                        // Handle file upload
                        function handleFileUpload(e) {
                        if (e.target.files && e.target.files[0]) {
                        // Hide upload section immediately
                        uploadSection.style.display = 'none';
                        
                        // Show loading spinner
                        showLoading(true);
                        
                        const selectedFile = e.target.files[0];
                        loadPDF(selectedFile);
                    }
                    }
                        
                        // Load PDF document
                        function loadPDF(pdfFile) {
                        showLoading(true);
                        
                        updateScaleForDevice();
                        
                        const fileReader = new FileReader();
                        
                        fileReader.onload = async (event) => {
                        try {
                        const typedArray = new Uint8Array(event.target.result);
                        
                        // Load the PDF document
                        const loadingTask = pdfjsLib.getDocument({ data: typedArray });
                    const pdf = await loadingTask.promise;
                    
                    pdfDocument = pdf;
                    totalPages = pdf.numPages;
                    currentPage = 1;
                    
                    // Update UI
                    totalPagesEl.textContent = totalPages;
                    currentPageEl.textContent = currentPage;
                    
                    // Show editor section with flex display
                    editorSection.style.display = 'flex';
                    
                    // Render all pages with the initial scale
                    renderAllPages(pdf, scale);
                } catch (error) {
                    console.error("Error loading PDF:", error);
                    //alert("Error loading PDF. Please try again with a different file.");
                    showToast('Error loading PDF. Please try again with a different file.', 'error');
                    uploadSection.style.display = 'block';
                    showLoading(false);
                }
                };
                
                fileReader.readAsArrayBuffer(pdfFile);
                }
                
                // Load PDF document from ID
                // Load PDF document from ID
                function loadPDFFromId(id, conId ,recid) {
                    
                    showLoading(true);
                    
                    updateScaleForDevice();
                    
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.JunosignPdfController.getPDFById}',
                        id,
                        conId,
                        recid,
                        function(result, event) {
                            if (event.status) {
                                try {
                                    const binaryString = window.atob(result);
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        bytes[i] = binaryString.charCodeAt(i);
                                    }
                                    const loadingTask = pdfjsLib.getDocument({ data: bytes });
                                    loadingTask.promise.then(pdf => {
                                        pdfDocument = pdf;
                                        totalPages = pdf.numPages;
                                        currentPage = 1;
                                        totalPagesEl.textContent = totalPages;
                                        currentPageEl.textContent = currentPage;
                                        renderAllPages(pdf, scale);
                                       
                                    }).catch(error => {
                                        console.error("Error loading PDF:", error);
                                        //alert("Error loading PDF: " + (error.message || "Unknown error"));
                                        showToast("Error loading PDF: " + (error.message || "Unknown error"), 'error');
                                        showLoading(false);
                                        editorSection.style.display = 'none';
                                    });
                                    } catch (error) {
                                        console.error("Error processing PDF data:", error);
                                        //alert("Error processing PDF data: " + (error.message || "Unknown error"));
                                        showToast("Error processing PDF data:" + (error.message || "Unknown error"), 'error');
                                        showLoading(false);
                                        editorSection.style.display = 'none';
                                    }
                                    } else {
                                        console.error("Error fetching PDF:", event.message);
                                        //alert("Error fetching PDF: " + event.message);
                                        showToast("Error fetching PDF: " + (error.message || "Unknown error"), 'error');
                                        showLoading(false);
                                        editorSection.style.display = 'none';
                                    }
                                    },
                                        { escape: false }
                                                            );
                                }
                                
                                // Render all PDF pages
                                async function renderAllPages(pdf, pageScale) {
                                    if (!pdfCanvas) return;
                                    
                                    // Clear existing canvas container
                                    pdfCanvasContainer.innerHTML = '';
                                    
                                    try {
                                        showLoading(true);
                                        
                                        // Get total pages
                                        totalPages = pdf.numPages;
                                        totalPagesEl.textContent = totalPages;
                                        
                                        // Create and render each page
                                        for (let pageNumber = 1; pageNumber <= totalPages; pageNumber++) {
                                            const page = await pdf.getPage(pageNumber);
                                            const stdViewprt = page.getViewport({ scale: 1 });
                                            //const currentScale = window.innerWidth < 768 ? window.innerWidth/stdViewprt.width : 1.4;
                                            const viewport = page.getViewport({ scale: pageScale });
                                            
                                            // Create a new canvas for each page
                                            const canvas = document.createElement('canvas');
                                            
                                            canvas.className = 'pdf-page-canvas';
                                            canvas.height = viewport.height;
                                            canvas.width = viewport.width;
                                            //canvas.style.marginBottom = '20px';
                                            canvas.style.boxShadow = '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)';
                                            canvas.style.backgroundColor = 'white';
                                            
                                            // Add page number indicator
                                            const pageIndicator = document.createElement('div');
                                            pageIndicator.className = 'page-indicator';
                                            pageIndicator.textContent = `Page ${pageNumber} of ${totalPages}`;
                                            pageIndicator.style.textAlign = 'center';
                                            pageIndicator.style.marginBottom = '10px';
                                            pageIndicator.style.fontWeight = '500';
                                            pageIndicator.style.color = '#6b7280';
                                            
                                            // Create a wrapper for each page
                                            const pageWrapper = document.createElement('div');
                                            pageWrapper.className = 'pdf-page-wrapper';
                                            pageWrapper.style.position = 'relative';
                                            pageWrapper.id = 'divPageNo_'+Number(pageNumber-1)
                                            //pageWrapper.appendChild(pageIndicator);
                                            pageWrapper.appendChild(canvas);
                                            
                                            // Add to container
                                            pdfCanvasContainer.appendChild(pageWrapper);
                                            
                                            // Render the page
                                            const context = canvas.getContext('2d');
                                            const renderContext = { canvasContext: context, viewport: viewport };
                                            await page.render(renderContext).promise;
                                        }
                                        
                                        // Hide loading spinner
                                        showLoading(false);
                                        
                                        // Since we're showing all pages, we don't need the page navigation controls
                                        document.querySelector('.page-controls').style.display = 'none';
                                        
                                        //load pads
                                       
                                    } catch (error) {
                                        console.error("Error rendering pages:", error);
                                        showLoading(false);
                                    }finally {
                                        window.setTimeout(function(){
                                        	buildPageTabs();
                                        }, 1000)
                                    	 
                                    }
                                }
                                
                                // Show/hide loading spinner
                                function showLoading(isLoading) {
                                    if (isLoading) {
                                        // Ensure canvas container is visible but overlay the spinner
                                        pdfCanvasContainer.style.display = 'block';
                                        loadingSpinner.style.display = 'flex';
                                        
                                        // Do not add 'hidden' class to keep canvas measurable
                                    } else {
                                        loadingSpinner.style.display = 'none';
                                        pdfCanvasContainer.classList.remove('hidden');
                                    }
                                }
                                
                                // Navigate to previous page
                                function prevPage() {
                                    if (currentPage > 1) {
                                        currentPage--;
                                        currentPageEl.textContent = currentPage;
                                        renderPage(pdfDocument, currentPage, scale);
                                        updateNavigationButtons();
                                    }
                                }
                                
                                // Navigate to next page
                                function nextPage() {
                                    if (currentPage < totalPages) {
                                        currentPage++;
                                        currentPageEl.textContent = currentPage;
                                        renderPage(pdfDocument, currentPage, scale);
                                        updateNavigationButtons();
                                    }
                                }
                                
                                // Update navigation buttons state
                                function updateNavigationButtons() {
                                    prevPageBtn.disabled = currentPage <= 1;
                                    nextPageBtn.disabled = currentPage >= totalPages;
                                }
                                
                                // Zoom in
                                function zoomIn() {
                                    scale += 0.2;
                                    zoomLevelEl.textContent = Math.round(scale * 100) + '%';
                                    renderAllPages(pdfDocument, scale);
                                }
                                
                                // Zoom out
                                function zoomOut() {
                                    if (scale > 0.4) {
                                        scale -= 0.2;
                                        zoomLevelEl.textContent = Math.round(scale * 100) + '%';
                                        renderAllPages(pdfDocument, scale);
                                    }
                                }
                                
                                // Make an element draggable and resizable with improved positioning
                                function makeDraggable(element) {
                                    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                                    
                                    // Add resize handles
                                    addResizeHandles(element);
                                    
                                    element.onmousedown = dragMouseDown;
                                    element.ontouchstart = dragTouchStart;
                                    
                                    function dragMouseDown(e) {
                                        // Skip if clicking on a resize handle
                                        if (e.target.classList.contains('resize-handle')) {
                                            return;
                                        }
                                        
                                        e.preventDefault();
                                        // Get the mouse cursor position at startup
                                        pos3 = e.clientX;
                                        pos4 = e.clientY;
                                        document.onmouseup = closeDragElement;
                                        // Call a function whenever the cursor moves
                                        document.onmousemove = elementDrag;
                                        
                                        // Add active class for styling
                                        element.classList.add("dragging");
                                    }
                                    
                                    function dragTouchStart(e) {
                                        // Skip if touching a resize handle
                                        if (e.target.classList.contains('resize-handle')) {
                                            return;
                                        }
                                        
                                        // Prevent scrolling while dragging
                                        e.preventDefault();
                                        
                                        // Get the touch position at startup
                                        const touch = e.touches[0];
                                        pos3 = touch.clientX;
                                        pos4 = touch.clientY;
                                        
                                        document.ontouchend = closeTouchDragElement;
                                        document.ontouchmove = elementTouchDrag;
                                        
                                        // Add active class for styling
                                        element.classList.add("dragging");
                                    }
                                    
                                    function elementDrag(e) {
                                        e.preventDefault();
                                        // Calculate the new cursor position
                                        pos1 = pos3 - e.clientX;
                                        pos2 = pos4 - e.clientY;
                                        pos3 = e.clientX;
                                        pos4 = e.clientY;
                                        
                                        // Set the element's new position
                                        const newTop = element.offsetTop - pos2;
                                        const newLeft = element.offsetLeft - pos1;
                                        
                                        // Get the current scroll position of the container
                                        const scrollTop = selectedTarget.parentElement.scrollTop; //pdfContainer.scrollTop;
                                        
                                        // Ensure the element stays within the PDF container bounds
                                        const pdfContainerRect = selectedTarget.parentElement.getBoundingClientRect();//pdfContainer.getBoundingClientRect();
                                        const elementRect = element.getBoundingClientRect();
                                        
                                        // Calculate boundaries
                                        const minLeft = 0;
                                        const maxLeft = pdfContainerRect.width - elementRect.width;
                                        const minTop = scrollTop; // Adjust for scroll position
                                        const maxTop = pdfContainer.scrollHeight - elementRect.height;
                                        
                                        // Apply boundaries
                                        const boundedLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
                                        const boundedTop = Math.max(minTop, Math.min(newTop, maxTop));
                                        
                                        // Update position
                                        element.style.top = boundedTop + 'px';
                                        element.style.left = boundedLeft + 'px';
                                    }
                                    
                                    function elementTouchDrag(e) {
                                        // Prevent scrolling while dragging
                                        e.preventDefault();
                                        
                                        const touch = e.touches[0];
                                        
                                        // Calculate the new touch position
                                        pos1 = pos3 - touch.clientX;
                                        pos2 = pos4 - touch.clientY;
                                        pos3 = touch.clientX;
                                        pos4 = touch.clientY;
                                        
                                        // Set the element's new position
                                        const newTop = element.offsetTop - pos2;
                                        const newLeft = element.offsetLeft - pos1;
                                        
                                        // Get the current scroll position of the container
                                        const scrollTop = selectedTarget.parentElement.scrollTop; //pdfContainer.scrollTop;
                                        
                                        // Ensure the element stays within the PDF container bounds
                                        const pdfContainerRect = selectedTarget.parentElement.getBoundingClientRect();// pdfContainer.getBoundingClientRect();
                                        const elementRect = element.getBoundingClientRect();
                                        
                                        // Calculate boundaries
                                        const minLeft = 0;
                                        const maxLeft = pdfContainerRect.width - elementRect.width;
                                        const minTop = scrollTop; // Adjust for scroll position
                                        const maxTop = pdfContainer.scrollHeight - elementRect.height;
                                        
                                        // Apply boundaries
                                        const boundedLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
                                        const boundedTop = Math.max(minTop, Math.min(newTop, maxTop));
                                        
                                        // Update position
                                        element.style.top = boundedTop + 'px';
                                        element.style.left = boundedLeft + 'px';
                                    }
                                    
                                    function closeDragElement() {
                                        // Stop moving when mouse button is released
                                        document.onmouseup = null;
                                        document.onmousemove = null;
                                        element.classList.remove("dragging");
                                    }
                                    
                                    function closeTouchDragElement() {
                                        // Stop moving when touch ends
                                        document.ontouchend = null;
                                        document.ontouchmove = null;
                                        element.classList.remove("dragging");
                                    }
                                }
                                
                                // Add resize handles to an element with improved functionality
                                function addResizeHandles(element) {
                                    // Create resize handles for all corners
                                    const positions = ['nw', 'ne', 'sw', 'se'];
                                    
                                    positions.forEach(pos => {
                                        const handle = document.createElement('div');
                                        handle.className = `resize-handle resize-handle-${pos}`;
                                                      element.appendChild(handle);
                                    
                                    // Add resize functionality to each handle
                                    handle.addEventListener('mousedown', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        startResize(e, pos, element);
                                    });
                                        
                                        // Add touch resize functionality
                                        handle.addEventListener('touchstart', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        startTouchResize(e, pos, element);
                                    });
                                    });
                                    }
                                        
                                        // Handle resize functionality with improved accuracy
                                        function startResize(e, position, element) {
                                        e.preventDefault();
                                        
                                        // Get the image inside the wrapper
                                        const img = element.querySelector('img');
                                        const dateElement = element.querySelector('.date-element');
                                        if (!img && !dateElement) return;
                                        
                                        let isResizing = true;
                                        let originalWidth, originalHeight, originalX, originalY;
                                        const originalMouseX = e.clientX;
                                        const originalMouseY = e.clientY;
                                        
                                        if (img) {
                                        originalWidth = img.offsetWidth;
                                        originalHeight = img.offsetHeight;
                                    } else {
                                        originalWidth = dateElement.offsetWidth;
                                        originalHeight = dateElement.offsetHeight;
                                    }
                                        
                                        originalX = element.offsetLeft;
                                        originalY = element.offsetTop;
                                        
                                        // Store original aspect ratio
                                        const aspectRatio = originalWidth / originalHeight;
                                        
                                        // Add a resize class to the element
                                        element.classList.add('resizing');
                                        
                                        function resize(e) {
                                        if (!isResizing) return;
                                        e.preventDefault();
                                        
                                        const deltaX = e.clientX - originalMouseX;
                                        const deltaY = e.clientY - originalMouseY;
                                        
                                        let newWidth = originalWidth;
                                        let newHeight = originalHeight;
                                        let newX = originalX;
                                        let newY = originalY;
                                        
                                        // Calculate new dimensions based on which handle is being dragged
                                        switch (position) {
                                        case 'se':
                                        newWidth = originalWidth + deltaX;
                                        newHeight = originalHeight + deltaY;
                                        break;
                                        case 'sw':
                                        newWidth = originalWidth - deltaX;
                                        newHeight = originalHeight + deltaY;
                                        newX = originalX + deltaX;
                                        break;
                                        case 'ne':
                                        newWidth = originalWidth + deltaX;
                                        newHeight = originalHeight - deltaY;
                                        newY = originalY + deltaY;
                                        break;
                                        case 'nw':
                                        newWidth = originalWidth - deltaX;
                                        newHeight = originalHeight - deltaY;
                                        newX = originalX + deltaX;
                                        newY = originalY + deltaY;
                                        break;
                                    }
                                                            
                                                            // Maintain aspect ratio for signatures (optional - remove if you want free resizing)
                                                            if (img && e.shiftKey) {
                                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                            newHeight = newWidth / aspectRatio;
                                        } else {
                                            newWidth = newHeight * aspectRatio;
                                        }
                                        
                                        // Adjust position for aspect ratio preservation
                                        if (position.includes('n')) {
                                            newY = originalY + (originalHeight - newHeight);
                                        }
                                        if (position.includes('w')) {
                                            newX = originalX + (originalWidth - newWidth);
                                        }
                                    }
                                    
                                    // Apply minimum size constraints
                                    const minSize = 30;
                                    if (newWidth < minSize) {
                                        newWidth = minSize;
                                        if (position.includes('w')) {
                                            newX = originalX + (originalWidth - minSize);
                                        }
                                    }
                                    if (newHeight < minSize) {
                                        newHeight = minSize;
                                        if (position.includes('n')) {
                                            newY = originalY + (originalHeight - minSize);
                                        }
                                    }
                                    
                                    // Update position and size
                                    element.style.left = `${newX}px`;
                                    element.style.top = `${newY}px`;
                                    
                                    if (img) {
                                        img.style.width = `${newWidth}px`;
                                        img.style.height = `${newHeight}px`;
                                    } else if (dateElement) {
                                        dateElement.style.width = `${newWidth}px`;
                                        dateElement.style.height = `${newHeight}px`;
                                    }
                                }
                                
                                function stopResize() {
                                    isResizing = false;
                                    element.classList.remove('resizing');
                                    document.removeEventListener('mousemove', resize);
                                    document.removeEventListener('mouseup', stopResize);
                                }
                                
                                document.addEventListener('mousemove', resize);
                                document.addEventListener('mouseup', stopResize);
                            }
                            
                            // Handle touch resize functionality
                            function startTouchResize(e, position, element) {
                                e.preventDefault();
                                
                                // Get the image inside the wrapper
                                const img = element.querySelector('img');
                                const dateElement = element.querySelector('.date-element');
                                if (!img && !dateElement) return;
                                
                                let isResizing = true;
                                let originalWidth, originalHeight, originalX, originalY;
                                const touch = e.touches[0];
                                const originalTouchX = touch.clientX;
                                const originalTouchY = touch.clientY;
                                
                                if (img) {
                                    originalWidth = img.offsetWidth;
                                    originalHeight = img.offsetHeight;
                                } else {
                                    originalWidth = dateElement.offsetWidth;
                                    originalHeight = dateElement.offsetHeight;
                                }
                                
                                originalX = element.offsetLeft;
                                originalY = element.offsetTop;
                                
                                // Store original aspect ratio
                                const aspectRatio = originalWidth / originalHeight;
                                
                                // Add a resize class to the element
                                element.classList.add('resizing');
                                
                                function touchResize(e) {
                                    if (!isResizing) return;
                                    e.preventDefault();
                                    
                                    const touch = e.touches[0];
                                    const deltaX = touch.clientX - originalTouchX;
                                    const deltaY = touch.clientY - originalTouchY;
                                    
                                    let newWidth = originalWidth;
                                    let newHeight = originalHeight;
                                    let newX = originalX;
                                    let newY = originalY;
                                    
                                    // Calculate new dimensions based on which handle is being dragged
                                    switch (position) {
                                        case 'se':
                                            newWidth = originalWidth + deltaX;
                                            newHeight = originalHeight + deltaY;
                                            break;
                                        case 'sw':
                                            newWidth = originalWidth - deltaX;
                                            newHeight = originalHeight + deltaY;
                                            newX = originalX + deltaX;
                                            break;
                                        case 'ne':
                                            newWidth = originalWidth + deltaX;
                                            newHeight = originalHeight - deltaY;
                                            newY = originalY + deltaY;
                                            break;
                                        case 'nw':
                                            newWidth = originalWidth - deltaX;
                                            newHeight = originalHeight - deltaY;
                                            newX = originalX + deltaX;
                                            newY = originalY + deltaY;
                                            break;
                                    }
                                    
                                    // Apply minimum size constraints
                                    const minSize = 30;
                                    if (newWidth < minSize) {
                                        newWidth = minSize;
                                        if (position.includes('w')) {
                                            newX = originalX + (originalWidth - minSize);
                                        }
                                    }
                                    if (newHeight < minSize) {
                                        newHeight = minSize;
                                        if (position.includes('n')) {
                                            newY = originalY + (originalHeight - minSize);
                                        }
                                    }
                                    
                                    // Update position and size
                                    element.style.left = `${newX}px`;
                                    element.style.top = `${newY}px`;
                                    
                                    if (img) {
                                        img.style.width = `${newWidth}px`;
                                        img.style.height = `${newHeight}px`;
                                    } else if (dateElement) {
                                        dateElement.style.width = `${newWidth}px`;
                                        dateElement.style.height = `${newHeight}px`;
                                    }
                                }
                                
                                function stopTouchResize() {
                                    isResizing = false;
                                    element.classList.remove('resizing');
                                    document.removeEventListener('touchmove', touchResize);
                                    document.removeEventListener('touchend', stopTouchResize);
                                }
                                
                                document.addEventListener('touchmove', touchResize);
                                document.addEventListener('touchend', stopTouchResize);
                            }
                            
                            // Handle drag over for drop zone
                            function handleDragOver(e) {
                                e.preventDefault();
                            }
                            
                            // Handle drop for signatures
                            function handleDrop(e) {
                                e.preventDefault();
                                
                                // Get the dragged element ID if it's from our app
                                const id = e.dataTransfer.getData('text/plain');
                                if (!id) return;
                                
                                const element = document.getElementById(id);
                                if (!element) return;
                                
                                // Calculate position relative to the PDF container
                                const rect = pdfContainer.getBoundingClientRect();
                                const x = e.clientX - rect.left;
                                const y = e.clientY - rect.top;
                                
                                // Update element position
                                element.style.left = x + 'px';
                                element.style.top = y + 'px';
                            }
                            
                            // Save edited PDF with improved positioning and scaling
                            async function savePDF() {
                                debugger
                                if (!pdfCanvasContainer) {
                                    //alert("PDF canvas not available. Please try again later.");
                                    showToast("PDF canvas not available. Please try again later.", 'error');
                                    return;
                                }
                                let signaturesElements = document.getElementsByClassName("signaturedragfield");
                                let completedIds = [];
                                if (signaturesElements?.length > 0) {
                                    //alert("Please add at least one signature or date before saving the PDF.");
                                    showToast("Please address signature/date/text before completing.", 'error');
                                    return;
                                }else {
                                    let completedSignElements = document.getElementsByClassName("signList")
                                    for(let i=0;i<completedSignElements.length;i++){
                                    	let ele = completedSignElements[i].id.split("_")[3];
                                    	completedIds.push(ele)
                                    }
                                    let completedTextElements = document.getElementsByClassName("dateList")
                                    for(let i=0;i<completedTextElements.length;i++){
                                    	let ele = completedTextElements[i].id.split("_")[3];
                                    	completedIds.push(ele)
                                    }
                                    let completedDateElements = document.getElementsByClassName("textList")
                                    for(let i=0;i<completedDateElements.length;i++){
                                    	let ele = completedDateElements[i].id.split("_")[3];
                                    	completedIds.push(ele)
                                    }
                                }
                                
                                try {
                                    showLoading(true);
                                    console.log("Starting PDF save process...");
                                    
                                    // Get the original PDF data
                                    const pdfBytes = await pdfDocument.getData();
                                    
                                    // Load the PDF with PDFLib
                                    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                                    
                                    // Get all pages
                                    const pages = pdfDoc.getPages();
                                    
                                    // Get all canvas elements (one per page)
                                    const canvasElements = document.querySelectorAll('.pdf-page-canvas');
                                    
                                    // Process each page
                                    for (let i = 0; i < totalPages; i++) {
                                        const page = pages[i];
                                        const canvas = canvasElements[i];
                                        
                                        if (!page || !canvas) continue;
                                        
                                        // Get page dimensions
                                        const { width, height } = page.getSize();
                                        console.log(`PDF page ${i+1} dimensions:`, width, "x", height);
                                        
                                        // Get canvas dimensions
                                        const canvasRect = canvas.getBoundingClientRect();
                                        
                                        // Calculate scaling factors - this is critical for correct positioning
                                        const xScale = width / (canvas.width / scale);
                                        const yScale = height / (canvas.height / scale);
                                        
                                        // Process all signatures and dates for this page
                                        for (const sig of signatures) {
                                            if (!sig.element) continue;
                                            
                                            const elementRect = sig.element.getBoundingClientRect();
                                            
                                            // Check if the signature is on this page
                                            // We determine this by checking if the signature's position overlaps with the canvas
                                            if (!(elementRect.bottom > canvasRect.top && 
                                                  elementRect.top < canvasRect.bottom)) {
                                                continue; // Skip if not on this page
                                            }
                                            
                                            // Calculate position relative to the canvas
                                            const relativeLeft = elementRect.left - canvasRect.left;
                                            const relativeTop = elementRect.top - canvasRect.top;
                                            
                                            // Convert to PDF coordinates with proper scaling
                                            const x = (relativeLeft / scale) * xScale;
                                            // PDF coordinates start from bottom, so we need to invert the y-coordinate
                                            const y = height - (relativeTop / scale) * yScale;
                                            
                                            if (sig.type === "date") {
                                                const dateElement = sig.element.querySelector(".date-element");
                                                if (dateElement) {
                                                    const text = dateElement.textContent || "";
                                                    const fontSize = 12;
                                                    page.drawText(text, {
                                                        x: x,
                                                        y: y - fontSize, // Adjust for text baseline
                                                        size: fontSize,
                                                        color: PDFLib.rgb(0.36, 0.13, 0.71),
                                                    });
                                                }
                                            } else if (sig.dataUrl) {
                                                const img = sig.element.querySelector(".signature-image");
                                                if (!img) continue;
                                                
                                                // Get the actual dimensions of the signature element
                                                const imgWidth = (elementRect.width / scale) * xScale;
                                                const imgHeight = (elementRect.height / scale) * yScale;
                                                
                                                try {
                                                    const dataUrl = sig.dataUrl;
                                                    const base64Data = dataUrl.split(",")[1];
                                                    const binaryString = window.atob(base64Data);
                                                    const bytes = new Uint8Array(binaryString.length);
                                                    for (let i = 0; i < binaryString.length; i++) {
                                                        bytes[i] = binaryString.charCodeAt(i);
                                                    }
                                                    
                                                    const isPng = dataUrl.includes("image/png");
                                                    let embeddedImage;
                                                    
                                                    if (isPng) {
                                                        embeddedImage = await pdfDoc.embedPng(bytes);
                                                    } else {
                                                        embeddedImage = await pdfDoc.embedJpg(bytes);
                                                    }
                                                    
                                                    // Draw the image at the correct position with the correct dimensions
                                                    page.drawImage(embeddedImage, {
                                                        x: x,
                                                        y: y - imgHeight, // Adjust for PDF coordinate system
                                                        width: imgWidth,
                                                        height: imgHeight,
                                                    });
                                                } catch (embedError) {
                                                    console.error("Error embedding image:", embedError);
                                                    // Fallback to a placeholder if image embedding fails
                                                    page.drawRectangle({
                                                        x: x,
                                                        y: y - imgHeight,
                                                        width: imgWidth,
                                                        height: imgHeight,
                                                        borderColor: PDFLib.rgb(0, 0, 0),
                                                        borderWidth: 1,
                                                        color: PDFLib.rgb(1, 0.9, 0.9),
                                                    });
                                                    page.drawText("Signature Placeholder", {
                                                        x: x + 10,
                                                        y: y - imgHeight / 2,
                                                        size: 12,
                                                        color: PDFLib.rgb(0, 0, 0),
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Save the PDF
                                    const modifiedPdfBytes = await pdfDoc.save();
                                    const blob = new Blob([modifiedPdfBytes], { type: "application/pdf" });
                                    const url = URL.createObjectURL(blob);
                                    const link = document.createElement("a");
                                    link.href = url;
                                    link.download = "signed-document.pdf";
                            		link.click();
                                    URL.revokeObjectURL(url);
                                    
                                    try {
                                        await savePDFToSalesforce(modifiedPdfBytes, completedIds);
                                    } catch (sfError) {
                                        console.error("Error saving to Salesforce:", sfError);
                                        //alert("PDF was downloaded but could not be saved to Salesforce. Check console for details.");
                                        showToast("PDF was downloaded but could not be saved to Salesforce. Check console for details.", 'error');
                                    }
                                    
                                    showLoading(false);
                                } catch (error) {
                                    console.error("Error saving PDF:", error);
                        			//alert("Error saving PDF: " + (error.message || "Unknown error"));
                        			showToast("Error saving PDF: " + (error.message || "Unknown error"), 'error');
                                    showLoading(false);
                                }
                            }
                            
                            // Save PDF to Salesforce with improved handling
                            function savePDFToSalesforce(pdfBytes, completedIds) {
                                return new Promise((resolve, reject) => {
                                    try {
                                    console.log("Starting Salesforce save process...");
                                    
                                    // Convert PDF bytes to base64
                                    const base64Data = arrayBufferToBase64(pdfBytes);
                                    console.log("Converted PDF to base64, length:", base64Data.length);
                                    
                                    // Prepare data for Salesforce
                                    const pdfData = 'data:application/pdf;base64,' + base64Data;
                                    
                                    // Get URL parameters
                                    const urlParams = new URLSearchParams(window.location.search);
                                    const recordId = urlParams.get('recid') || ''; // Use RecipientId (capital 'R') as recid
                                    
                                    const conid = urlParams.get('conid') || ''; // Use conid for parent object
                                    console.log("Recipient ID:", recordId, "Con ID:", conid);
                                    
                                    // Validate recordId
                                    if (!recordId) {
                                    console.error("RecipientId is missing from URL parameters");
                                    alert('Error: Missing RecipientId in URL parameters');
                                    reject(new Error('Missing RecipientId'));
                                    return;
                                }
                                                   
                                                   // Call Apex method to save to Salesforce
                                                   console.log("Calling Salesforce remoting...");
                                Visualforce.remoting.Manager.invokeAction(
                                    '{!$RemoteAction.JunosignPdfController.savePDFToSalesforce}',
                                    'Signed Document VIA',
                                    pdfData,
                                    recordId,
                                    conid,
                                    completedIds,
                                    function(result, event) {
                                        if (event.status) {
                                            try {
                                                const response = JSON.parse(result);
                                                if (response.status === 'success') {
                                                    console.log("Salesforce save successful:", response.contentVersionId);
                                                    // Show success modal and disable editing
                                                    showSuccessModal();
                                                    // disableEditing();
                                                    resolve(response.contentVersionId);
                                                } else {
                                                    console.error("Salesforce save failed:", response.message);
                                                    alert('PDF was downloaded but could not be saved to Salesforce: ' + response.message);
                                                    reject(new Error(response.message));
                                                }
                                            } catch (e) {
                                                console.error("Error parsing response:", e);
                                                alert('Error processing server response: ' + e.message);
                                                reject(e);
                                            }
                                        } else {
                                            console.error("Salesforce remoting failed:", event.message);
                                            alert('PDF was downloaded but could not be saved to Salesforce: ' + event.message);
                                            reject(new Error(event.message));
                                        }
                                    },
                                    { 
                                        escape: false,  // Important for handling large data
                                        timeout: 120000 // Extend timeout for large files
                                    }
                                );
                            } catch (error) {
                                console.error('Error in savePDFToSalesforce:', error);
                                alert('Error in savePDFToSalesforce: ' + error.message);
                                reject(error);
                            }
                        });
                }
                
                // Helper function to convert ArrayBuffer to base64 with chunking for large files
                function arrayBufferToBase64(buffer) {
                    const bytes = new Uint8Array(buffer);
                    const len = bytes.byteLength;
                    let binary = '';
                    
                    // Process in chunks to avoid memory issues
                    const chunkSize = 65536; // 64KB chunks
                    for (let i = 0; i < len; i += chunkSize) {
                        const chunk = bytes.slice(i, Math.min(i + chunkSize, len));
                        for (let j = 0; j < chunk.length; j++) {
                            binary += String.fromCharCode(chunk[j]);
                        }
                    }
                    
                    return window.btoa(binary);
                }
                
                // Reset editor
                function resetEditor() {
                    // Clear signatures
                    signatures.forEach(sig => {
                        if (sig.element) {
                        sig.element.remove();
                    }
                                       });
                    signatures = [];
                    
                    // Reset UI
                    pdfDocument = null;
                    currentPage = 1;
                    totalPages = 0;
                    scale = 1.0;
                    zoomLevelEl.textContent = '100%';
                    
                    // Reload the page to start fresh
                    window.location.reload();
                }
                
                function showRejectionModal() {
                    const rejectionModal = document.getElementById('rejectionModal');
                    rejectionModal.style.display = 'flex';
                    
                    const closeTabBtn = document.getElementById('closeTabBtn');
                    closeTabBtn.removeEventListener('click', closeTabHandler);
                    closeTabBtn.addEventListener('click', closeTabHandler);
                }
                
                function showSuccessModal() {
                    const successModal = document.getElementById('successModal');
                    if (!successModal) {
                        console.error("Success modal element not found");
                        alert("Error: Success modal not found in the page");
                        return;
                    }
                    successModal.style.display = 'flex';
                    
                    const closeSuccessTabBtn = document.getElementById('closeSuccessTabBtn');
                    if (!closeSuccessTabBtn) {
                        console.error("Close success tab button not found");
                        alert("Error: Close success tab button not found in the page");
                        return;
                    }
                    // Remove any existing listeners to prevent duplicates
                    closeSuccessTabBtn.removeEventListener('click', closeTabHandler);
                    closeSuccessTabBtn.addEventListener('click', closeTabHandler);
                }
                function closeTabHandler() {
                    window.close();
                }
            
            // helper to scale and apply important styles
            function applyScaledStyles(el, left, top, width, height, fontSize, isChild) {
                let styleStr = '';
                
                if (!isChild) {
                    styleStr += `
                    position:absolute !important;
                    top:${top};
                    left:${left};
                    `;
                }
                
                if (window.innerWidth < 768) {
                    if (width && isChild)
                        styleStr += `width:${(parseFloat(width) * scale)/2}px !important;min-width:${(parseFloat(width) * scale)/2}px !important;`;
                    if (height && isChild)
                        styleStr += `height:${(parseFloat(height) * scale)/4}px !important;padding:2px;`;
                    if (fontSize && isChild)
                        styleStr += `font-size:${(parseFloat(fontSize) * scale)-6}px !important;`;
                }
                
                //  Preserve original styles in dataset
                if (!el.dataset.originalStyle) {
                    el.dataset.originalStyle = el.style.cssText; 
                }
                
                //  Append new styles without removing old ones
                el.style.cssText += styleStr;
            }
            function buildPageTabs() {
                debugger
                document.getElementById('saveBtn').disabled = true;
                var signCount = 0, textCount = 0, initialCount = 0, dateCount = 0;
                
                let usersidepagepadList = JSON.parse('{!JSENCODE(pageTabsstring)}');
                if (usersidepagepadList.length) {
                    
                    //  Device check for scaling
                    let isMobile = window.innerWidth <= 768;
                    let scale = isMobile ? (window.innerWidth / 612) : 1.4;
                    
                    
                    
                    for (var i = 0; i < usersidepagepadList.length; i++) {
                        let txtnode = document.createElement('DIV');
                        let item = usersidepagepadList[i];
                        
                        if (item.type == 'text' || item.type == 'initial') {
                            if (!document.getElementById('textList_' + item.Name + '_' + item.Id)) {
                                txtnode.setAttribute("class", 'textList');
                                txtnode.setAttribute("id", 'textList_' + item.Name + '_' + item.Id);
                                txtnode.setAttribute('data-texttype', item.type);
                                
                                
                                
                                if (item.type == 'text') {
                                    var leftVal ;topVal ;
                                    if(usersidepagepadList[i].type == 'text'){
                                        leftVal = usersidepagepadList[i]['left']
                                        
                                        topVal = usersidepagepadList[i]['top']
                                        txtnode.style.top = topVal
                                        txtnode.style.left = leftVal
                                        txtnode.style.position = 'absolute'
                                        txtnode.setAttribute('data-textorderno',textCount);
                                        textCount++;
                                    }
                                    txtnode.setAttribute('data-textorderno', textCount++);
                                    txtnode.setAttribute('data-texttype','text');
                                    
                                    txtnode.setAttribute("class",'textList'); //listitem droppedElement
                                    txtnode.setAttribute("id",'textList_'+usersidepagepadList[i]['Name']+'_'+usersidepagepadList[i]['Id']);
                                    
                                    txtnode.style.padding= '3px;'
                                    txtnode.innerHTML = '<div class="signaturedragfield textInput" data-type="text" style="padding:0 !important;justify-content:center;" onclick="openSignaturePad(event)">Add Text Here</div>';
                                } else {
                                    txtnode.setAttribute("class",'listitem textList intialList');//droppedElement
                                    
                                    var leftVal = usersidepagepadList[i]['left']
                                    
                                    var topVal = usersidepagepadList[i]['top']
                                    $(txtnode).css('top',topVal)
                                    $(txtnode).css('left',leftVal)
                                    txtnode.setAttribute('data-initialorderno',initialCount);
                                    initialCount++;
                                    
                                    
                                    txtnode.setAttribute("class",'listitem textList intialList'); //droppedElement
                                    txtnode.setAttribute('data-texttype','initial')
                                    txtnode.setAttribute("id",'textList_'+usersidepagepadList[i]['Name']+'_'+usersidepagepadList[i]['Id']);
                                    txtnode.setAttribute("data-tempid",'autoScrollItem_'+usersidepagepadList[i]['Name']);
                                    txtnode.setAttribute("data-scrollid",'autoScrollItem');
                                    txtnode.style.top = topVal
                                    txtnode.style.left = leftVal
                                    txtnode.style.position = 'absolute'
                                    txtnode.setAttribute("class", 'listitem textList intialList');
                                    txtnode.setAttribute('data-initialorderno', initialCount++);
                                    txtnode.innerHTML = '<div class="signaturedragfield textInput" data-type="initial" style="padding:0 !important;justify-content:center;" onclick="openSignaturePad(event)">Add Initial Here</div>';
                                }
                                
                               
                                let ele = document.getElementById(item.Name);
                                if (ele) {
                                    ele.append(txtnode);
                                    /* Auto scrolling to sign/initials */
                                    if(usersidepagepadList[i].type == 'initial'){
                                        txtnode.children[0].onblur = function(event){
                                            let dropDiv =  document.getElementById("drop");
                                            let initialsList = document.getElementsByClassName('listitem textList intialList');
                                            let emptyInitials = false;
                                            let pageNo = event.target.parentElement.id.split('_')[2];
                                            autoScrollToDivs(pageNo);
                                        }
                                    }
                                }
                                if(window.innerWidth < 768){
                                    let width = txtnode.offsetWidth;
                                    let height = txtnode.offsetHeight;
                                    let fontSize = window.getComputedStyle(txtnode).fontSize.replace("px", "");
                                    
                                    applyScaledStyles(txtnode, item.left, item.top, 125, height, fontSize, false);
                                    
                                    //  also scale child element(s)
                                    Array.from(txtnode.children).forEach(child => {
                                        let cWidth = child.offsetWidth;
                                        let cHeight = child.offsetHeight;
                                        let cFontSize = window.getComputedStyle(child).fontSize.replace("px", "");
                                        applyScaledStyles(child, item.left, item.top, cWidth, cHeight, cFontSize, true);
                                    });
                                }
                            }
                        }
                        else if (item.type == 'signature') {
                            if (!document.getElementById('signList_' + item.Name + '_' + item.Id)) {
                                txtnode.setAttribute("class",'signList'); //listitem droppedElement
                                txtnode.setAttribute("id",'signList_'+usersidepagepadList[i]['Name']+'_'+usersidepagepadList[i]['Id']);
                                txtnode.setAttribute("data-tempid",'autoScrollItem_'+usersidepagepadList[i]['Name']);
                                txtnode.setAttribute("data-scrollid",'autoScrollItem');
                                var left = usersidepagepadList[i]['left']
                                //var leftVal = left+'px'
                                var topVal = usersidepagepadList[i]['top']
                                
                                var leftVal = usersidepagepadList[i]['left']
                                txtnode.setAttribute('data-signorderno',signCount);
                                signCount++;
                                txtnode.style.top = topVal
                                txtnode.style.left = leftVal
                                txtnode.style.margin = '0'
                                txtnode.style.position = 'absolute'
                                txtnode.innerHTML = '<div class="signaturedragfield" id="signeditIcon" data-type="signature" style="padding:0px !important;justify-content: center;" onclick="openSignaturePad(event) "> Sign Here </div> ';
                                
                                
                                let ele = document.getElementById(item.Name);
                                if (ele) ele.append(txtnode);
                                if(window.innerWidth < 768){
                                    let width = txtnode.offsetWidth;
                                    let height = txtnode.offsetHeight;
                                    let fontSize = window.getComputedStyle(txtnode).fontSize.replace("px", "");
                                    
                                    applyScaledStyles(txtnode, item.left, item.top, 125, height, fontSize, false);
                                    
                                    //  also scale child element(s)
                                    Array.from(txtnode.children).forEach(child => {
                                        let cWidth = child.offsetWidth;
                                        let cHeight = child.offsetHeight;
                                        let cFontSize = window.getComputedStyle(child).fontSize.replace("px", "");
                                        applyScaledStyles(child, item.left, item.top, cWidth, cHeight, cFontSize, true);
                                    });
                                }
                                
                            }
                        }
                            else if (item.type == 'date') {
                                if (!document.getElementById('dateList_' + item.Name + '_' + item.Id)) {
                                    var dt = new Date();
                                    var todayDate = '{!todayDateValue}';// dt.toLocaleDateString()
                                    var dateValDiv = document.createElement('DIV')
                                    // dateValDiv.innerHTML = ' <div class="dateEle dateValue" style="min-width:5rem;">'+todayDate+'</div>';  
                                    dateValDiv.innerHTML = '<div class="signaturedragfield textInput" id="textEdit" data-type="date" style="padding:0px !important;justify-content: center;" onclick="addDate(event) "> MM/DD/YYYY </div> ';
                                    dateValDiv.innerHTML+= `<div class="reset-icon" onclick="resetField(this)"  style="display:none;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                            <path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/>
                                                </svg>
                                            </div>`
                                            var topVal = usersidepagepadList[i]['top']
                                            
                                            var leftVal = usersidepagepadList[i]['left']
                                            
                                            let datesEle = document.getElementsByClassName('dateEle');
                                    
                                    dateValDiv.setAttribute("class", 'listitem dateList ') //droppedElement
                                    dateValDiv.setAttribute("id",'dateList_'+usersidepagepadList[i]['Name']+'_'+usersidepagepadList[i]['Id']);
                                    dateValDiv.setAttribute("data-datespanno", datesEle.length) //usersidepagepadList[i]['JunoDoc__Pos_Top__c']
                                    dateValDiv.setAttribute("style","position:absolute;top:"+(topVal)+";left:"+(leftVal)+";");
                                    dateValDiv.setAttribute('data-dateorderno',dateCount);
                                    dateCount++;
                                    
                                    let ele = document.getElementById(item.Name);
                                    if (ele) ele.append(dateValDiv);
                                    if(window.innerWidth < 768){
                                        let width = txtnode.offsetWidth;
                                        let height = txtnode.offsetHeight;
                                        let fontSize = window.getComputedStyle(txtnode).fontSize.replace("px", "");
                                        
                                        applyScaledStyles(dateValDiv, item.left, item.top, 125, height, fontSize, false);
                                        
                                        //  also scale child element(s)
                                        
                                            let cWidth = dateValDiv.children[0].offsetWidth;
                                            let cHeight = dateValDiv.children[0].offsetHeight;
                                            let cFontSize = window.getComputedStyle(dateValDiv.children[0]).fontSize.replace("px", "");
                                            applyScaledStyles(dateValDiv.children[0], item.left, item.top, cWidth, cHeight, cFontSize, true);
                                       
                                    }
                                }
                            }
                    }
                    document.getElementById('saveBtn').disabled = false;
                } else {
                    document.getElementById('saveBtn').disabled = true;
                    showSuccessModal();
                }
            }

            
            function makeContainerResponsive() {
                var wrapper = document.getElementById('editorSection');
                if (!wrapper) return;
                
                var wrapperWidth = wrapper.clientWidth;
                var wrapperHeight = wrapper.clientHeight;
                
                var pageWidthEl = document.getElementById('divPageNo_0');
                var pageWidth = pageWidthEl ? pageWidthEl.clientWidth : 0;
                
                if (!pageWidth) {
                    var pdfContainer = document.getElementById('pdfContainer');
                    pageWidth = pdfContainer ? pdfContainer.clientWidth : wrapperWidth;
                }
                
                var ratio = wrapperWidth / pageWidth;
                if (ratio > 1) {
                    ratio = 1;
                }
                
                const isMobile = window.innerWidth < 768;
                const isLandscape = window.innerWidth > window.innerHeight;
                
                if (isMobile) {
                    // Mobile-specific adjustments
                    if (isLandscape) {
                        // Landscape mode - optimize for horizontal space
                        wrapper.style.height = '100vh';
                        wrapper.style.width = '100vw';
                    } else {
                        // Portrait mode - optimize for vertical space
                        wrapper.style.height = '100vh';
                        wrapper.style.width = '100vw';
                    }
                    
                    // Adjust PDF container for mobile
                    var pdfContainer = document.getElementById('pdfContainer');
                    if (pdfContainer) {
                        pdfContainer.style.padding = isLandscape ? '0.5rem' : '1rem';
                    }
                    
                    // Adjust toolbar for mobile
                    var toolbar = document.querySelector('.editor-toolbar');
                    if (toolbar) {
                        toolbar.style.padding = isLandscape ? '0.5rem' : '0.75rem';
                        toolbar.style.flexWrap = 'wrap';
                    }
                } else {
                    // Desktop adjustments
                    wrapper.style.height = (wrapperHeight * ratio) + 'px';
                    wrapper.style.width = wrapperWidth + 'px';
                }
                
                var pdfCanvasContainer = document.querySelector('.pdf-canvas-container');
                if (pdfCanvasContainer && isMobile) {
                    pdfCanvasContainer.style.transformOrigin = "center top";
                    if (isLandscape) {
                        pdfCanvasContainer.style.transform = "scale(0.9)";
                    } else {
                        pdfCanvasContainer.style.transform = "scale(1)";
                    }
                }
                
                if (wrapperWidth < 600) {
                    var modals = document.querySelectorAll('.signature-modal, .date-picker-modal');
                    modals.forEach(modal => {
                        if (modal) {
                            modal.style.padding = '1rem';
                            var modalContent = modal.querySelector('.signature-modal-content, .date-picker-modal-content');
                            if (modalContent) {
                                modalContent.style.width = '95vw';
                                modalContent.style.maxWidth = '95vw';
                                modalContent.style.margin = '0 auto';
                            }
                        }
                    });
                }
                
                var headerDiv = document.querySelector('.headerDiv');
                if (headerDiv) {
                    headerDiv.style.width = (wrapperWidth * 0.98) + 'px';
                }
                
                var headerBtns = document.querySelector('.headerBtns');
                if (headerBtns) {
                    var computedStyle = window.getComputedStyle(headerBtns);
                    var fontSize = parseFloat(computedStyle.fontSize);
                    headerBtns.style.fontSize = (fontSize * ratio) + 'px';
                    headerBtns.style.fontWeight = '500';
                }
                
                var imgDiv = document.querySelector('.imgDiv');
                if (imgDiv) {
                    var imgWidth = imgDiv.clientWidth;
                    imgDiv.style.width = (imgWidth * 0.8466) + 'px';
                }
            }
            
            
            // Call on load and resize
            //window.addEventListener('load', makeContainerResponsive);
            //window.addEventListener('resize', makeContainerResponsive);
            
            function showToast(message, type) {
                var toast = document.getElementById('toast');
                var toastMessage = document.getElementById('toastMessage');
                //var toastIcon = document.getElementById('toastIcon');
                
                toastMessage.innerText = message;
                
                // Reset classes
                toast.className = 'slds-notify slds-notify_toast';
                
                // Set theme based on type
                if (type === 'success') {
                    toast.classList.add('slds-theme_success');
                    /*toastIcon.innerHTML = `
                    <svg class="slds-icon slds-icon_small slds-icon-text-default" aria-hidden="true"> 
                        <use xmlns:xlink="http://www.w3.org/1999/xlink"  xlink:href="https://www.lightningdesignsystem.com/assets/icons/utility-sprite/svg/symbols.svg#success"></use>
                        </svg>
                        `;*/
                } else if (type === 'error') {
                    toast.classList.add('slds-theme_error');
                    /*toastIcon.innerHTML = `
                    <svg class="slds-icon slds-icon_small slds-icon-text-default" aria-hidden="true">
                        <use xmlns:xlink="http://www.w3.org/1999/xlink"  xlink:href="https://www.lightningdesignsystem.com/assets/icons/utility-sprite/svg/symbols.svg#error"></use>
                        </svg>
                        `;*/
                } else if (type === 'info') {
                    toast.classList.add('slds-theme_info');
                    /*toastIcon.innerHTML = `
                    <svg class="slds-icon slds-icon_small slds-icon-text-default" aria-hidden="true">
                        <use xmlns:xlink="http://www.w3.org/1999/xlink"  xlink:href="https://www.lightningdesignsystem.com/assets/icons/utility-sprite/svg/symbols.svg#info"></use>
                        </svg>
                        `;*/
                } else {
                    // Default to info
                    toast.classList.add('slds-theme_info');
                    /*toastIcon.innerHTML = `
                    <svg class="slds-icon slds-icon_small slds-icon-text-default" aria-hidden="true">
                        <use xlink:href="https://www.lightningdesignsystem.com/assets/icons/utility-sprite/svg/symbols.svg#info"></use>
                        </svg>
                        `;*/
                }
                
                toast.style.display = 'block';
                
                setTimeout(function() {
                        toast.style.display = 'none';
                }, 3000);
            }
            
            // helper for scaled styles
            function applyScaledStylesreset(el, left, top, width, height, fontSize, scale = 1) {
                el.style.position = "absolute";
                el.style.left = left;
                el.style.top = top;
                el.style.width = (parseFloat(width) * scale) + "px";
                el.style.height = (parseFloat(height) * scale) + "px";
                el.style.fontSize = (parseFloat(fontSize) * scale) + "px";
                el.style.display = "flex";
                el.style.alignItems = "center";
                el.style.justifyContent = "center";
            }
            
            
            function resetField(wrapperElement) {
                const parent = wrapperElement.parentElement.parentElement;
                let type = parent.parentElement.id.includes('date') ? 'date' : parent.parentElement.id.includes('text') ? 'text' : parent.parentElement.id.includes('sign') ? 'signature':''
                
                
                
                // Create placeholder again
                const placeholder = document.createElement('div');
                placeholder.className = 'signaturedragfield';
                placeholder.style = 'padding:0px !important;justify-content: center;';
                
                switch(type) {
                    case 'signature':
                        placeholder.textContent = 'Sign Here';
                        placeholder.setAttribute('id', 'signeditIcon')
                        placeholder.dataset.type = 'signature';
                        placeholder.addEventListener('click', openSignaturePad);
                        break;
                    case 'date':
                        placeholder.className = 'signaturedragfield textInput';
                        placeholder.textContent = 'MM/DD/YYYY';
                        placeholder.setAttribute('id', 'textEdit')
                        placeholder.dataset.type = 'date';
                        placeholder.addEventListener('click', addDate);
                        break;
                    case 'text':
                        placeholder.className = 'signaturedragfield textInput';    
                        placeholder.textContent = 'Add Text Here';
                        placeholder.dataset.type = 'text';
                        placeholder.addEventListener('click', openSignaturePad); // Or your text modal handler
                        break;
                }
                
                parent.parentElement.appendChild(placeholder);
                parent.remove();
                if(window.innerWidth < 768){
                    let width = placeholder.parentElement.offsetWidth;
                    let height = placeholder.parentElement.offsetHeight;
                    let fontSize = window.getComputedStyle(placeholder.parentElement).fontSize.replace("px", "");
                    
                    applyScaledStyles(placeholder.parentElement , placeholder.parentElement.style.left, placeholder.parentElement.style.top, 125, height, fontSize, false);
                    
                    //  also scale child element(s)
                    Array.from(placeholder.parentElement.children).forEach(child => {
                        let cWidth = child.offsetWidth;
                        let cHeight = child.offsetHeight;
                        let cFontSize = window.getComputedStyle(child).fontSize.replace("px", "");
                        applyScaledStyles(child, placeholder.parentElement.style.left, placeholder.parentElement.style.top, cWidth, cHeight, cFontSize, true);
                    });
                }
                
            }



            function handleOrientationChange() {
                setTimeout(() => {
                    isMobile = window.innerWidth < 768;
                    isLandscape = window.innerWidth > window.innerHeight;
                    currentOrientation = screen.orientation ? screen.orientation.angle : 0;
                    
                    // Recalculate scale based on new orientation
                    updateScaleForDevice();
                    
                    // Re-render PDF with new scale if document is loaded
                    if (pdfDocument) {
                        renderAllPages(pdfDocument, scale);
                    }
                    
                    // Update container responsiveness
                    makeContainerResponsive();
                    
                    // Reposition signature elements for new orientation
                    repositionSignatureElements();
                }, 100); // Small delay to ensure orientation change is complete
            }

            function handleResize() {
                isMobile = window.innerWidth < 768;
                isLandscape = window.innerWidth > window.innerHeight;
                
                updateScaleForDevice();
                makeContainerResponsive();
                repositionSignatureElements();
            }

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function updateScaleForDevice() {
                if (isMobile) {
                    // Adjust scale based on orientation for mobile
                    scale = isLandscape ? 1.0 : 1.2;
                } else {
                    scale = 1.4; // Desktop scale
                }
                
                const zoomLevelEl = document.getElementById('zoomLevel');
                if (zoomLevelEl) {
                    zoomLevelEl.textContent = Math.round(scale * 100) + '%';
                }
            }

            function repositionSignatureElements() {
                const signatureElements = document.querySelectorAll('[id^="wrapper-"]');
                signatureElements.forEach(element => {
                    // Ensure elements stay within bounds after orientation change
                    const rect = element.getBoundingClientRect();
                    const container = element.parentElement;
                    const containerRect = container.getBoundingClientRect();
                    
                    // Adjust position if element is outside container bounds
                    let newLeft = parseInt(element.style.left) || 0;
                    let newTop = parseInt(element.style.top) || 0;
                    
                    if (newLeft + rect.width > containerRect.width) {
                        newLeft = containerRect.width - rect.width - 10;
                    }
                    if (newTop + rect.height > containerRect.height) {
                        newTop = containerRect.height - rect.height - 10;
                    }
                    
                    element.style.left = Math.max(0, newLeft) + 'px';
                    element.style.top = Math.max(0, newTop) + 'px';
                });
            }
            
            // Enhanced validation function
function validateRecipientAccess() {
    const urlParams = new URLSearchParams(window.location.search);
    const recid = urlParams.get('recid');
    const id = urlParams.get('id');
    const conid = urlParams.get('conid');
    
    if (!recid) {
        showErrorModal('Missing recipient ID. Cannot validate access.');
        return;
    }
    
    showLoading(true);
    
    Visualforce.remoting.Manager.invokeAction(
        '{!$RemoteAction.JunosignPdfController.validateRecipientAccess}',
        recid,
        function(result, event) {
            showLoading(false);
            
            if (event.status) {
                console.log('Validation result:', result);
                
                if (result.isValid) {
                    // ALL conditions passed - load the PDF
                    loadPDFFromId(id, conid, recid);
                } else {
                    // Show appropriate error message with all validation failures
                    showErrorModal(result.errorMessage, result.errorType, result.validationErrors);
                }
            } else {
                showErrorModal('Error validating access: ' + event.message, 'VALIDATION_ERROR');
            }
        },
        { escape: false }
    );
}

// Enhanced error modal with multiple validation errors
function showErrorModal(message, errorType, validationErrors) {
    const errorModal = document.createElement('div');
    errorModal.className = 'error-modal';
    
    let errorContent = `
        <div class="error-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none">
                <circle cx="12" cy="12" r="10" fill="#dc2626"/>
                <path d="M8 8l8 8m0-8l-8 8" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
            </svg>
        </div>
        <h2>Access Denied</h2>
    `;
    
    if (validationErrors && validationErrors.length > 0) {
        errorContent += '<div class="validation-errors">';
        validationErrors.forEach(error => {
            errorContent += `<p class="error-item">${error}</p>`;
        });
        errorContent += '</div>';
    } else {
        errorContent += `<p>${message}</p>`;
    }
    
    errorContent += `
        <button onclick="closeTab()" class="btn btn-primary">Close Tab</button>
    `;
    
    errorModal.innerHTML = `<div class="error-modal-content">${errorContent}</div>`;
    
    errorModal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.8); display: flex; align-items: center; 
        justify-content: center; z-index: 10000; padding: 1rem;
    `;
    
    // Hide the main content
    const editorSection = document.getElementById('editorSection');
    if (editorSection) {
        editorSection.style.display = 'none';
    }
    
    document.body.appendChild(errorModal);
}

function closeTab() {
    window.close();
}

// Add CSS for error modal
const errorModalStyles = `
    .error-modal-content {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        text-align: center;
        max-width: 500px;
        margin: 1rem;
        max-height: 80vh;
        overflow-y: auto;
    }
    
    .error-icon {
        width: 60px;
        height: 60px;
        background: #fee2e2;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 1rem;
    }
    
    .error-modal h2 {
        color: #dc2626;
        margin-bottom: 1rem;
        font-size: 1.5rem;
    }
    
    .error-modal p {
        color: #4b5563;
        margin-bottom: 1rem;
        line-height: 1.5;
    }
    
    .validation-errors {
        text-align: left;
        margin: 1rem 0;
        padding: 1rem;
        background: #fef2f2;
        border-radius: 4px;
        border-left: 4px solid #dc2626;
    }
    
    .error-item {
        color: #dc2626;
        margin-bottom: 0.5rem;
        padding-left: 0.5rem;
    }
    
    .error-item:last-child {
        margin-bottom: 0;
    }
    
    .btn-primary {
        background: linear-gradient(90deg, #7c3aed 0%, #2563eb 100%);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        margin-top: 1rem;
    }
    
    .btn-primary:hover {
        opacity: 0.9;
    }
`;

// Add styles to document
const styleSheet = document.createElement('style');
styleSheet.textContent = errorModalStyles;
document.head.appendChild(styleSheet);
            
                </script>
                <apex:includeScript value="{!$Resource.JunoSignManager}" />
            </body>
        </apex:form>
        
    </html>
</apex:page>